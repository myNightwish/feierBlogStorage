---
title: HTTP
tags: 计网
categories: 3.3-基础
cover: >-
  https://images.unsplash.com/photo-1639218690253-f2f69df61251?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80
copyright_author: 飞儿
copyright_url: 'https://www.nesxc.com/post/hexocc.html'
license: CC BY-NC-SA 4.0
license_url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/'
abbrlink: 2716721158
date: 2021-12-11 23:30:10
---
### 1、HTTP概述 ###

#### 1、是什么： ####

1. 超文本传输协议，基于TCP/IP协议，**是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范**
2. 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息

#### 2、特点： ####

##### 1、灵活可扩展 #####

* 一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。
* 另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据

##### 2、请求-应答模式 #####

* 通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等

##### 3、可靠传输 #####

* HTTP是基于TCP/IP，因此把这一特性继承了下来

##### 4、无状态 #####

* 指协议对于事物处理没有记忆能力。不对请求和响应之间的通信状态进行保存

* 缺少状态意味着如果后续处理需要前面的信息，则它必须重传

* 无状态协议解决办法：

  1、通过、Cookie  

  2、通过Session会话保存

#### 3、优、缺点 ####

##### 1、无状态 #####

* 有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等
* 另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说

##### 2、明文传输 #####

* 即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式
* 这让HTTP的报文信息暴露给了外界，给攻击者带来了便利
* 不验证对方信息，会遭遇伪装；

##### 3、队头阻塞 #####

* 当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题

### 2、HTTP 状态码 ###

RFC 规定 HTTP 的状态码为**「三位数」**，第一个数字定义了响应的类别，被分为五类:

* **「1xx」**: 代表请求已被接受，需要继续处理。
* **「2xx」**: 表示成功状态。
* **「3xx」**: 重定向状态。
* **「4xx」**: 客户端错误。
* **「5xx」**: 服务器端错误。

#### 1、1xx 信息类 ####

* 100继续 ：指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100允许客户端继续或用417告诉客户端不同意接受附件。     HTTP 1.1中新加入的
* 101转换协议：指服务器将按照其上的头信息变为一个不同的协议。 HTTP 1.1中新加入的

#### 2、2xx 成功 ####

* 200 （成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页
* 201 （已创建） 请求成功并且服务器创建了新的资源
* 204：请求得到了成功处理，但返回的响应报文中不含实体的主体部分（没有资源可以返回）

* 206 Partial Content，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求 响应报文中包含由 **「Content-Range」** 指定范围的实体内容。

#### 3、3xx 重定向 ####

##### 同样是重定向，**307**，**303**，**302**的区别？ #####

* 302是http1.0的状态码，在http1.1版本的时候为了细化302状态码出来了两个303和307。

  *  303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。

* 307会遵照浏览器标准，不会从post变为get。

* 301 （永久移动）表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI，新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。

  * 若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址
  * 使用场景：
    * 当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。
    * 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。

* 302 （临时移动） 表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。

  *  302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。
  *  若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。
  *  同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。
  *  使用场景：
     * 当我们在做活动时，登录到首页自动重定向，进入活动页面。
     * 未登陆的用户访问用户中心重定向到登录页面。
     * 访问404页面重新定向到首页。

* 303 （查看其他位置）表示由于请求对应的资源存在另一个 URI，应使用 GET 方法定向获取请求的资源

  * 和 302 Found 相似功能，但 303 状态码明确表示客户端应当用 GET 方法获取资源
  * 303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。
  * 注意：
    * 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。
    * 301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做

* **304 （未修改，协商缓存可用） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。** 

  304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系

  1. **产生较多304状态码的原因：**

     * 页面更新周期长或不更新
     * 纯静态页面或强制生成静态html

  2. **304状态码出现过多会造成以下问题：**

     * 网站快照停止；
     * 收录减少；
     * 权重下降。

  3. **HTTP状态码304是多好还是少好**

     搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。

     若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累的回访率也会高

* 305 （使用**代理**） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。

* 307 （临时重定向）会遵守浏览器标准，**不会从 POST 变成 GET**。但对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容

#### 4、4XX 客户端错误 ####

* 400  请求报文存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

* 401 unauthorized，表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败。

  * 返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。

  * 出现401场景：
    * 401.1 - 登录失败。
    * 401.2 - 服务器配置导致登录失败。
    * 401.3 - 由于 ACL 对资源的限制而未获得授权。
    * 401.4 - 筛选器授权失败。
    * 401.5 - ISAPI/CGI 应用程序授权失败。
    * 401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。

* 403 forbidden，表示对请求资源的访问被服务器拒绝。服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。**进入该状态后，不能再继续进行验证。**该访问是永久禁止的，并且与应用逻辑密切相关。

* 404 not found，表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 以下情况会出现404：

* 405  表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。

  GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下

  ```
  Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE
  ```

#### 5、5XX 服务器错误 ####

* 500 internal sever error，表示服务器端在执行请求时发生了错误。
* 502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。
* 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。

### 3、HTTP版本差异 ###

#### 1、HTTP 0.9 ####

* 91年,原型版本，功能简陋，只有一个命令GET,只支持纯文本内容，已过时。

#### 2、HTTP 1.0 ####

* 任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件
* 除了GET命令，还引入了POST命令和HEAD命令
* http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
* 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。
* 不支持断点续传，也就是说，每次都会传送全部的页面和数据。
* 通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）

#### 3、HTTP 1.1 ####

**http1.1是目前最为主流的http协议版本**，从1999年发布至今，仍是主流的http协议版本。

* 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 `keep-alive` 来设置
* 引入了管道机制，即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率
* HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效
* 支持断点续传，通过使用请求头中的 `Range` 来实现
* 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址
* 新增方法：PUT、 PATCH、 OPTIONS、 DELETE

#### 3.2、总结1.0与1.1区别 ####

* **连接方面**

  http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延

* **资源请求方面**

  在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接

* **缓存方面**，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。

* http1.1 中**新增了 host 字段**，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。

* http1.1 相对于 http1.0 还新增了很多**请求方法**，如 PUT、HEAD、OPTIONS 等。

#### 4、http1.x版本问题 ####

* #### 安全： ####

  在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性

* #### 队头阻塞： ####

  HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞

* #### Keep-alive性能问题 ####

  http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间 

#### 5、HTTP 2.0 ####

##### 1、`二进制分帧`   #####

* 这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。
* HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。

##### 2、`头部压缩`   #####

* HTTP 1.1版本会出现 **「User-Agent、Cookie、Accept、Server、Range」** 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。
* HTTP 2.0 使用 `HPACK` 算法进行压缩。

##### 3、`多路复用`  #####

* 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。

##### 4、`服务器推送`  #####

* 允许服务器未经请求，主动向客户端发送资源，即服务器推送。

##### 5、`请求优先级`  #####

* 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验

#### 6、3.0  QUIC 协议 ####

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45a0a2ec0ef143b49d79256cea543418~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:25%;" />

##### 1. 特点： #####

* HTTP/3 是基于 UDP 实现的，实现了类似于 TCP 的多路数据流、传输可靠性等功能，称为 QUIC 协议
  * 实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。
  * 集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。
  * 实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。
  * 实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。

##### 2. HTTP/3 的挑战 #####

* 第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。
* 第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。
* 第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。

### 4、对HTTP/2理解 ###

#### 1、头部压缩 ####

* 由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。

  * 所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

  * **「User-Agent、Cookie、Accept、Server、Range」** 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重

* HTTP/2 实现了头信息压缩，引入了头信息压缩机制。

  * 一方面，头信息使用 gzip 或 compress 压缩后再发送；
  * 另一方面，客户端和服务器同时维护一张头信息表`HPACK` 算法，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了

* #### `HPACK` 算法：  传索引 ####

  * 类似于索引表，每个索引表对应一个值，比如索引为2对应头部中的method头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引
  * 对于之前出现过的头部信息，只需要把**「索引」**(比如1，2，...)传给对方，对方拿到索引查表就行了

<img src="https://user-images.githubusercontent.com/34484322/89356545-a3fd4100-d6f0-11ea-8e0a-8870d832e96e.png" alt="img" style="zoom: 33%;" />

* #### 好处： ####

  1. 这种**「传索引」**的方式，可以说让请求头字段得到极大程度的精简和复用

  2. 其次是对于整数和字符串进行**「哈夫曼编码」**

     哈夫曼编码的原理就是先将所有出现的字符建立一张索引表

     然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的**「索引序列」**，可以达到非常高的压缩率

#### 2、多路复用 ####

HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。

##### HTTP2中： #####

* 同域名下所有通信都在单个连接上完成。

* 单个连接可以承载任意数量的双向数据流。

* 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是`Stream ID`，流标识符

  有了它，接收方就能从乱序的二进制帧中选择ID相同的帧，按照顺序组装成请求/响应报文。

* HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了**"队头堵塞"**的问题。

#### 3、服务器推送 ####

* HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送，这样就可以相对减少一些延迟时间
* 需要注意的是 http2 下服务器主动推送的是**静态资源**，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

##### 相比较http/1.1的优势👇 #####

* 推送资源可以由不同页面共享
* 服务器可以按照优先级推送资源
* 客户端可以缓存推送的资源
* 客户端可以拒收推送过来的资源

#### 4、二进制分帧与数据流 ####

##### 二进制帧： #####

* 在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。

* HTTP/2 则是一个彻底的二进制协议，一个报文格式就被拆分为一个个二进制帧，帧的概念是它实现多路复用的基础。

  * 用**「Headers帧」**存放头部字段，**「Data帧」**存放请求体数据。这样子的话，就是一堆乱序的二进制帧，它们不存在先后关系，因此不需要排队等待，解决了HTTP队头阻塞问题

  * HTTP/2采用二进制格式，全部传输01串，便于机器解码

    明文传输，不方便计算机解析，对于回车换行符来说到底是内容还是分隔符，都需要内部状态机去识别，这样子效率低

##### 数据流： #####

* 在客户端与服务器之间，双方都可以互相发送二进制帧，这样子**「双向传输的序列」**，称为`流`，所以HTTP/2中以**流**来**表示一个TCP连接上进行多个数据帧的通信**，这就是**多路复用**概念
* HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。
  * HTTP/2 将每个请求或回应的所有数据包，称为一个数据流；
  * 每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。

##### 那乱序的二进制帧，是如何组装成对于的报文呢？ #####

* 乱序，指的是不同ID的Stream是乱序的，对于同一个Stream ID的帧是按顺序传输的
* 接收方收到二进制帧后，将相同的Stream ID组装成完整的请求报文和响应报文
* 二进制帧中有一些字段，控制着`优先级`和`流量控制`等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验

##### 队头阻塞 #####

* 队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的；
* HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。
* 队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理；
* 如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。

### 5、keep-alive ###

#### 1、什么是keep-alive ####

* #### 普通模式： ####

  HTTP协议采用“请求-应答”模式，当使用普通模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接，这就是**短连接**。（HTTP协议为无连接的协议）

* #### Keep-Alive模式： ####

  当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接 ，这就是**长连接**。

#### 2、为什么要使用keep-alive ####

* **创建目的：**能在多次HTTP之前重用同一个TCP连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等）

<img src="https://user-images.githubusercontent.com/34484322/89356849-64832480-d6f1-11ea-8f53-5372f8c30f39.png" alt="img" style="zoom:50%;" />

* 优点：
  * 较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；
  * 允许请求和应答的HTTP管线化；
  * 降低拥塞控制 （TCP连接减少了）；
  * 减少了后续请求的延迟（⽆需再进⾏握⼿）；
  * 报告错误⽆需关闭TCP连；
* 缺点：长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。

#### 3、客户端如何开启 ####

Keep-Alive的**建立过程**：

* 客户端向服务器在发送请求报文同时在首部添加发送Connection字段
* 服务器收到请求并处理 Connection字段
* 服务器回送Connection:Keep-Alive字段给客户端
* 客户端接收到Connection字段
* Keep-Alive连接建立成功

**服务端自动断开过程（也就是没有keep-alive）**：

* 客户端向服务器只是发送内容报文（不包含Connection字段）
* 服务器收到请求并处理
* 服务器返回客户端请求的资源并关闭连接
* 客户端接收资源，发现没有Connection字段，断开连接

**客户端请求断开连接过程**：

* 客户端向服务器发送Connection:close字段
* 服务器收到请求并处理connection字段
* 服务器回送响应资源并断开连接
* 客户端接收资源并断开连接

### 6、请求方法get/post ###

#### 1、HTTP请求方法 ####

* HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法
* HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

`http/1.1`规定了以下请求方法(注意，都是大写):

* GET：                请求获取Request-URI所标识的资源

* POST：              在Request-URI所标识的资源后附加新的数据

* HEAD：             请求获取由Request-URI所标识的资源的响应消息报头，没有响应体

* PUT：                请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）

  * PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等
  * 也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时**更新数据**）

* OPTIONS：       用于请求获得由`Request-URI`标识的资源在请求/响应的通信过程中可以使用的功能选项

  * 通过这个方法，客户端可以**在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能**。该请求方法的响应不能缓存。

  OPTIONS请求方法的**主要用途**有两个：

  * 获取服务器对该资源支持的所有HTTP请求方法；

    该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。

  * 用来检查访问权限。例如：JS 的 XMLHttpRequest对象在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。

* DELETE：          请求服务器删除对应所标识的资源

* TRACE：            请求服务器回送收到的请求信息，主要用于测试或诊断

* CONNECT：      建立连接隧道，用于代理服务器

#### 2、谈一谈GET 和 POST 的区别 ####

本质上，只是语义上的区别，GET 用于获取资源，POST 用于提交资源。

从应用场景角度来看，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册

想装逼请参考 https://zhuanlan.zhihu.com/p/22536382

##### 1、缓存角度 #####

* GET 请求后浏览器会主动缓存，POST 默认情况下不能

##### 2、参数角度 #####

* GET请求一般放在URL中，因此不太安全，因为请求的 url 会被保留在历史记录中
* POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的

##### 3、编码角度 #####

* GET请求只能进行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。

##### 3.2、请求长度：  #####

* 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。

  **为什么会限制长度？**

  * 实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。
  * get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。

  ```javascript
  GET的长度值 = URL（2083）- （你的Domain+Path）-2（2是get请求中?=两个字符的长度）
  ```

##### 4、请求幂等 #####

* GET请求幂等
* POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致

##### 5、请求时 #####

* GET请求会一次性发送请求报文
* POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分

#### 3、POST与PUT的区别 ####

- PUT不会产生新数据，只是覆盖老数据，是幂等的
- POST请求一次就产生一个新数据，是非幂等的

### 6.1、请求头、响应头 ###

#### **HTTP Request Header 常见的请求头：** ####

```
* Accept:浏览器能够处理的内容类型
* Accept-Charset:浏览器能够显示的字符集
* Accept-Encoding：浏览器能够处理的压缩编码
* Accept-Ranges：可以请求网页实体的一个或者多个子范围字段
* Connection：浏览器与服务器之间连接的类型
* Cookie：当前页面设置的任何Cookie
* Host：发出请求的页面所在的域
* Referer：发出请求的页面的URL
* User-Agent：浏览器的用户代理字符串
```

#### 响应头： ####

```
HTTP Responses Header 常见的响应头：

Date：表示消息发送的时间，时间的描述格式由rfc822定义
server:服务器名称
Connection：浏览器与服务器之间连接的类型
Cache-Control：控制HTTP缓存
content-type:表示后面的文档属于什么MIME类型
```

#### 常见的 Content-Type 属性值有四种： ####

（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。

（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

（3）application/json：服务器消息主体是序列化后的 JSON 字符串。

（4）text/xml：该种方式主要用来提交 XML 格式的数据。

### 7、对URL组成 ###

#### 1、URL与URI ####

* URI：统一资源标识符         

  父类        表示请求服务器资源，定位这个资源

* URL：统一资源定位符，常常被称为网址，是因特网上标准的资源地址

  子类       而URL还要表示如何访问这个资源

  通用的格式：scheme://host[:port]/path/…/?query#anchor

#### 2、组成格式： ####

```
https://www.aspxfans.com:8080/news/index.…
```

* **协议：**访问服务器以获取资源时要使用哪种协议，比如：http，https 和 FTP 等后面一定接上://

* **域名：**该URL的域名部分为“www.aspxfans.com”

* **port：**跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。

  * 端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口

* （HTTP协议默认端口是80，HTTPS协议默认端口是443）；

* **虚拟目录部分**：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”；

* **文件名部分**：从域名后的最后一个“/”开始到“？”为止，是文件名部分

  * 如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分
  * 如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。
  * 本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；

* **锚部分**：从“#”开始到最后，都是锚部分。本例的锚部分是“name”。锚部分也不是一个URL必须的部分；

* **参数部分**：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。

  本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。

#### 3、URL 编码 ####

* URL 只能使用 [ASCII 字符集](https://link.juejin.cn?target=https%3A%2F%2Fwww.w3school.com.cn%2Ftags%2Fhtml_ref_ascii.asp)来通过因特网进行发送。
* 由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。
* URL 编码使用 "%" 其后跟随两位的十六进制数来替换非 ASCII 字符。
* URL 不能包含空格。URL 编码通常使用 + 来替换空格。

```
天天`转换为有效的ASCII格式就是`%CC%EC%CC%EC
```

### 8、队头阻塞问题 ###

#### 1、什么是队头阻塞？ ####

* 对于每一个HTTP请求而言，这些任务是会被放入一个任务队列中串行执行的
* 一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是`HTTP队头阻塞`问题

#### 2、解决1：并发连接 ####

* 我们知道对于一个域名而言，是允许分配多个长连接的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务
* 在`RFC规范`中规定客户端最多并发2个连接，不过实际情况就是要比这个还要多，举个例子，Chrome中是6个。

#### 3、解决2：域名分片 ####

* 可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器
* 就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题

比如`TianTian.com`，可以分出很多二级域名，比如`Day1.TianTian.com`，`Day2.TianTian.com`,`Day3.TianTian.com`,这样子就可以有效解决队头阻塞问题

### 9、谈一谈HTTP数据传输 ###

大概遇到的情况就分为**「定长数据」** 与 **「不定长数据」**的处理吧。

#### 1、定长数据 ####

* 发送端在发送数据的过程中，需要设置`Content-Length`,来指明发送数据的长度。如果采用了Gzip压缩的话，Content-Length设置的就是压缩后的传输长度

【注意】：

* Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致，也就是说，如果过短就会截断，过长的话，就会导致超时。
* 如果采用短链接的话，直接可以通过服务器关闭连接来确定消息的传输长度。
* 那么在HTTP/1.0之前的版本中，Content-Length字段可有可无,因为一旦服务器关闭连接，我们就可以获取到传输数据的长度了。
* 在HTTP/1.1版本中，如果是Keep-alive的话，chunked优先级高于`Content-Length`,若是非Keep-alive，跟前面情况一样，Content-Length可有可无

#### 2、不定长数据 ####

现在采用最多的就是HTTP/1.1版本，来完成传输数据，在保存Keep-alive状态下，当数据是不定长的时候，我们需要设置新的头部字段👇

```
Transfer-Encoding: chunked
```

通过chunked机制，可以完成对不定长数据的处理，当然了，你需要知道的是

* 如果头部信息中有`Transfer-Encoding`,优先采用Transfer-Encoding里面的方法来找到对应的长度。
* 如果设置了Transfer-Encoding，那么Content-Length将被忽视。
* 使用长连接的话，会持续的推送动态内容。

那我们来模拟一下吧👇

```
const server = require('http').createServer();
server.on('request', (req, res) => {
  if(req.url === '/index') {
   // 设置数据类型
    res.setHeader('Content-Type', 'text/html; charset=utf8');
    res.setHeader('Content-Length', 10);
    res.setHeader('Transfer-Encoding', 'chunked');
    
    res.write("你好，使用的是Transfer-Encoding设置传输数据形式");
    setTimeout(() => {
      res.write("第一次传输数据给您<br/>");
    }, 1000);
    res.write("骚等一下");
    setTimeout(() => {
      res.write("第一次传输数据给您");
      res.end()
    }, 3000);
  }
})

server.listen(3000, () => {
  console.log("成功启动--TinaTian");
})
```

