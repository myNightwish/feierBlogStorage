---
title: 我不允许你还不知道啥是HTTP缓存
categories: 3.2-浏览器
description: Http缓存原理
cover: https://cdn.jsdelivr.net/gh/myNightwish/CDN_res/Project/http_cache.webp
copyright_author: 飞儿
copyright_url: 'https://www.nesxc.com/post/hexocc.html'
license: CC BY-NC-SA 4.0
license_url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/'
abbrlink: http_cache
date: 2021-12-22 15:31:27
---
## HTTP缓存 ##

### 1、缓存基本 ###

* #### 概念： ####

  浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了

* #### 为什么要有缓存？ ####

  1. 减少了请求的次数，提高了网站的性能，加快客户端加载网页的速度， 提升用户体验。

     浏览器的缓存，主要针对的是前端的静态资源，最好的效果是，在发请求之后，拉取相应的静态资源，并存在本地。

  * 如果服务器的静态资源没更新，那在下次请求时，就直接从本地读取即可
  * 如果服务器的静态资源已更新，那再次请求时，就到服务器拉取新的资源，并存在本地

  2. 降低服务器的压力

* #### 分类 ####

  * 命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，**即客户端与服务器之间存在一次通信。**

  * 在 `chrome` 中**强缓存**（虽然没发出真实的 `http` 请求）的**请求状态码**返回是 `200 (from cache)`；

  * 而命中协商缓存，请求状态码是 `304 (not modified)`

    > 其中 from cache 会分为 from disk cache 和 from memory cache. 从内存中获取最快，但是是 session 级别的缓存，关闭浏览器之后就没有了。
    > ![image.png](https://segmentfault.com/img/remote/1460000021661660)

### 2、请求流程 ###

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f6837d8d1c74cf2894d8967a20115d9~tplv-k3u1fbpfcp-watermark.awebp" alt="业务流程图1.png" style="zoom: 50%;" />

1. 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 `response header` ，以供下次加载时对比使用；

2. 下一次加载资源时，会获取该缓存资源的 `header` 中的信息。由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差：

   如果没有超过`cache-control` 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则用 `expires` 头判断是否过期；

3. 如果资源已过期，则表明**强制缓存没被命中，则协商缓存**，浏览器就会发送请求到服务器，这次请求会带上 `IF-Modified-Since` 或者 `IF-None-Match`, 它们的值分别是第一次请求返回 `Last-Modified`或者 `Etag`

4. 服务器收到请求后，优先根据  `Etag`的值判断被请求的文件有没有做修改

   *  `Etag`值一致则没有修改，命中协商缓存，返回 304；
   *  如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；

   很多网站的资源后面都加了版本号，目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器缓存，**强制改变版本号**，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，**以保证用户能够及时获得网站的最新更新。**

### 3. 强缓存 ###

强缓存是根据返回头中的 `Expires` 或者 `Cache-Control` 两个字段来控制的，都是表示资源的缓存有效时间。

* `Expires` ：http 1.0，值是一个`GMT` 格式的时间点字符串，比如 `Expires:Mon,18 Oct 2066 23:59:59 GMT` 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存
  * 缺点：失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。
* `Cache-Control`： `http 1.1` 的规范，一般常用该字段的 `max-age` 值来进行判断，它是一个相对时间，比如 .`Cache-Control:max-age=3600` 代表资源的有效期是 3600 秒。并且返回头中的 `Date` 表示消息发送的时间，表示当前资源在 `Date ~ Date +3600s` 这段时间里都是有效的。`Cache-Control` 还有其他几个值可以设置：
  * `no-cache` 不使用本地缓存。需要使用协商缓存。
  * `no-store`直接禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源， 类似于 `network` 中的 `disabled cache`。
  * `public` 可以被所有用户缓存，包括终端用户和 cdn 等中间件代理服务器。
  * `private` 只能被终端用户的浏览器缓存。
* 如果 `Cache-Control`与 `Expires` 同时存在的话， `Cache-Control` 的优先级高于 `Expires` 

### 4. 协商缓存 ###

由服务器来确定缓存资源是否可用，这次请求会带上 `IF-Modified-Since` 或者 `IF-None-Match`, 它们的值分别是第一次请求返回 `Last-Modified`或者 `Etag`，由服务器来对比这一对字段来判断是否命中。如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段

* `Last-Modified/If-Modified-Since` ：二者的值都是 GMT 格式的时间字符串，

  `Last-Modified` ：标记最后文件修改时间， 下一次请求时，请求头中会带上 `If-Modified-Since` 值就是 `Last-Modified` 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化

  * 如果文件没有变更则返回 `304 Not Modified` ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 `304 Not Modified` 的响应时，`response header` 中不会再添加的 `Last-Modified` 去试图更新本地缓存的 `Last-Modified`， 因为没变化
  * 如果资源有变化，就正常返回返回资源内容，新的 `Last-Modified` 会在 `response header` 返回，并在下次请求之前更新本地缓存的 `Last-Modified`，下次请求时，`If-Modified-Since`会启用更新后的 `Last-Modified`。

* `Etag/If-None-Match`：值都是由服务器为每一个资源生成的**唯一标识串**，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 `ETag`字段返回给浏览器，接收到 `If-None-Match` 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。

  * 与 `Last-Modified` **不一样的是**，当服务器返回 `304 Not Modified` 的响应时，由于在服务器上`ETag` 重新计算过，`response header`中还会把这个 `ETag` 返回，即使这个 `ETag` 跟之前的没变化

```
优先级： Cache-Control  > expires > Etag > Last-Modified
```

### 5. 为什么要有 Etag ###

`HTTP1.1` 中 `Etag` 的出现主要是为了解决几个 `Last-Modified` 比较难解决的问题：

1. 时间的精确度：

   某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，`If-Modified-Since` 能检查到的粒度是秒级的，这样会造成缓存命中的不准确。使用 `Etag` 就能够保证这种需求下客户端在 1 秒内能刷新 N 次 cache。

2. 周期性改动：

   一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；

### 6. 用户行为 ###

用户行为对浏览器缓存的影响：

| 用户操作         | Expires/Cache-Control              | Last-Modied/Etag |
| ---------------- | ---------------------------------- | ---------------- |
| 地址栏回车       | 有效                               | 有效             |
| 页面链接跳转     | 有效                               | 有效             |
| 新开窗口         | 有效                               | 有效             |
| 前进回退         | 有效                               | 有效             |
| F5 刷新          | 无效(有争议，不同浏览器反馈不一致) | 有效             |
| Ctrl+F5 强制刷新 | 无效                               | 无效             |

* **点击刷新按钮或者按 F5：** 浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。

  **用户按 Ctrl+F5（强制刷新）：** 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。

  地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。

### 浏览器资源缓存的位置 ###

资源缓存的位置一共有 3 种，按优先级从高到低分别是：

1. **Service Worker**：Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。
   * 它可以让我们自由控制缓存哪些文件、如何匹配缓存、读取缓存，且**缓存是持续性的**。
   * 当 Service Worker 没有命中缓存的时候，需要去调用 `fetch` 函数获取  数据。也就是说，会根据缓存查找优先级去查找数据。
   * **但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。**
2. **Memory Cache：** 内存缓存，效率最快，**但持续性很短，会随着进程的释放而释放。**一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
3. **Disk Cache：** 硬盘缓存，读取速度慢点，但是什么都能存储到磁盘中
   * 比之 Memory Cache **胜在容量和存储时效性上。**
   * 它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。**并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。**

**Push Cache：** 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：

* 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
* 可以推送 `no-cache` 和 `no-store` 的资源
* 一旦连接被关闭，Push Cache 就被释放
* 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
* Push Cache 中的缓存只能被使用一次
* 浏览器可以拒绝接受已经存在的资源推送
* 可以给其他域名推送资源