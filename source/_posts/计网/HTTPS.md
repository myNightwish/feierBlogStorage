---
title: HTTPS
tags:
  - HTTPS
  - 安全
categories: 3.3-基础
description: HTTPS的加密方法
cover: https://cdn.jsdeliver.net/gh/myNightwish/CDN_res/img/HTTPs.webp
copyright_author: 飞儿
copyright_url: 'https://www.nesxc.com/post/hexocc.html'
license: CC BY-NC-SA 4.0
license_url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/'
abbrlink: HTTPS
date: 2021-12-11 23:30:18
---
## 1. HTTPS 概述 ##

### 1、什么是HTTPS ###

* HTTPS：HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

  * HTTP协议采用**明文传输**信息，存在**信息窃听**、**信息篡改**和**信息劫持**的风险，
  * 而协议TLS/SSL具有**身份验证**、**信息加密**和**完整性校验**的功能，可以避免此类问题发生
  * 安全层的主要职责就是**对发起的HTTP请求的数据进行加密操作** 和 **对接收到的HTTP的内容进行解密操作**。

  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10885a9d4d574d7caf3fee1416f623ca~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:25%;" />

* **SSL：**是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输

* http默认采用**80**作为通讯端口，传输不加密

* https默认采用**443**，对于传输的数据进行加密传输。 主流

### 2、TSL工作原理 ###

**TLS/SSL**全称**安全传输层协议**， 是介于TCP和HTTP之间的一层安全协议
## 2. 对称加密 ##

<img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704172932212-1865243822.png" alt="img" style="zoom: 67%;" />

* **特点：**客户端、服务端的对称加密算法的加密和解密都是用**同一个密钥**
* **安全性问题：**
  1. 密钥需要通过网络传输，怎么让传输的双方知晓，同时不被别人知道？
  2. 传输过程中密钥被别人劫持，之后他就能用密钥解开双方传输的任何内容

## 3. 非对称加密             单向安全 ##

<img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704172950412-1093634792.png" alt="img" style="zoom:67%;" />

* #### 特点：不需担心公钥泄露，确保了客户端发送到服务端数据的安全 ####

  1. 非对称加密需要**一组密钥对**，分别是**公钥**和**私钥**，这两个密钥是成对出现的。
  2. **公钥加密的内容需要对应的私钥解密，私钥加密的内容需要对应的公钥解密**
  3. 私钥由服务器自己保存，**公钥发送给客户端**
  4. 客户端拿到公钥后对请求加密后发送给服务端，服务器收到后用私钥解开

## 4. 非对称加密改良           双向安全但解密慢 ##

<img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173037022-575825113.png" alt="img" style="zoom:67%;" />

* #### 传输过程： ####

  服务器拥有用于非对称加密的公钥A1、私钥A2；浏览器拥有用于非对称加密的公钥B1、私钥B2

  1. 浏览器向服务器请求，服务器把公钥A1明文传输给浏览器

  2. 浏览器把公钥B1明文传输给服务器

  3. 之后浏览器向服务器传输的所有东西都用公钥A1加密，服务器收到后用私钥A2解密

     由于只有服务器拥有私钥A2进行解密，所以能保证这条数据的安全

  4. 服务器向浏览器传输的东西都用公钥B1加密，浏览器收到后用私钥B2解密。同上也可以保证这条数据的安全。

* #### 但HTTPS并没有用这种方案 ####

  最主要的原因是非对称加密算法非常耗时，而对称加密快很多。能不能运用**非对称加密的特性**解决对称加密中**公钥传输的安全传输**问题？？

* #### 仍存在的漏洞：中间人攻击 ####

## 5. 非对称加密 + 对称加密          HTTPS采用的加密方案 ##

<img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173049712-841772692.png" alt="img" style="zoom:67%;" />

* #### 过程： 只需要服务端有一对公、私钥对 ####

  服务器拥有用于非对称加密的公钥A1、私钥A2

  1. 浏览器向服务器请求，服务器把公钥A1明文给传输浏览器
  2. 浏览器随机生成一个用于对称加密的密钥X，用公钥A1加密后传给服务器
  3. 服务器拿到后用私钥A2解密得到密钥X
  4. 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密即可

* #### 漏洞：中间人攻击   中间人完全不需要拿到私钥A2就能劫持信息 ####

## 6. 中间人攻击 ##

![img](https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173100652-22100951.png)

* #### 过程： ####

  服务器用于非对称加密的公钥A1、私钥A2

  1. 浏览器向服务器请求，服务器把公钥A1明文传输给浏览器
  2. 中间人劫持到公钥A1，保存下来，把数据包中的公钥A1替换成自己伪造的公钥B1（它当然也拥有公钥B1对应的私钥B2）
  3. 浏览器随机生成一个用于对称加密的密钥X，用公钥B1（浏览器不知道公钥被替换了）加密后传给服务器
  4. 中间人劫持后用私钥B2解密得到密钥X，再用公钥A1加密后传给服务器
  5. 在双方都不会发现异常的情况下，中间人得到了对称密钥X

* #### 根本原因：浏览器无法确认自己收到的公钥是不是服务端自己的，下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？ ####

## 7. 数字证书 ##

* 网站在使用HTTPS前，需要向“**CA机构**”申请颁发一**数字证书**，数字证书里有**证书持有者、证书持有者的公钥等信息**

* 服务器把证书传输给浏览器，浏览器**从证书里取公钥**就可以了

* #### 问题： ####

  证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？数字证书怎么防伪呢？

## 8. 数字签名 ##

### 1. 数字签名的制作过程： ###

1. CA拥有非对称加密的私钥和公钥。
2. CA对证书明文信息进行hash。
3. 对hash后的值用私钥加密，得到数字签名
4. **明文和数字签名共同组成了数字证书**，这样一份数字证书就可以颁发给网站了

### 2. 浏览器验证过程： ###

1. 拿到证书，得到明文T1，数字签名S1。
2. 用CA机构的公钥对S1解密（由于是浏览器信任的机构，所以**浏览器保有它的公钥**），得到S2。
3. 用证书里说明的hash算法对明文T1进行hash得到T2。
4. 比较S2是否等于T2，等于则表明证书可信。

* 下图中左侧是数字签名的制作过程，右侧是验证过程

<img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173241563-445049817.png" alt="img" style="zoom:67%;" />

### 3. 为什么这样可以证明证书可信？ ###

* 假设中间人篡改了证书的原文，**由于他没有CA机构的私钥**，所以无法得到此时加密后签名，无法相应地篡改签名。
* 浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人

### 4. 既然不可能篡改，那如果整个证书被掉包呢？ ###

* 假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。
* 于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞
* **其实这并不会发生**，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。

### 5. 制作数字签名时为什么需要hash一次？ ###

#### 性能问题： ####

* 非对称加密是非常耗时和耗性能的；
* 对一个字符加密和对100个字符加密哪个更快一些？越短加密越快
* 证书的明文基本都很长，但是经过hash之后都很短，而且基本都是固定的长度了

### 6. HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？ ###

显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？

* 用session就可以，相当于服务器那里有个小本本记录着
* 服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下
* 之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了

## 9. HTTPS 工作原理 ##

<img src="https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173337291-1775767129.png" alt="img" style="zoom:67%;" />

1. **发请求**

   client向server发送请求https://baidu.com，然后连接到server的443端口。

2. 服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。

3. **传送证书**
   这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。

4. **客户端解析证书**
   这部分工作是由客户端的TLS来完成的，首先会**验证公钥是否有效**，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。

5. **传送加密信息**
   这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥（随机值），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

6. **服务端加密信息**
   服务端用私钥解密，得到了客户端传过来的密钥（随机值），然后把内容通过该值进行对称加密。

7. **传输加密后的信息**
   这部分信息是服务端用密钥（随机值）对称加密后的信息，可以在客户端被还原。

8. **客户端解密信息**
   客户端用之前生成的密钥（随机值）解密服务端传过来的信息，于是获取了解密后的内容。