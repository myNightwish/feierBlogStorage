---
title: 项目2-去哪儿网：项目记录篇
tags: Vue
categories: 2.4-项目
cover: >-
  https://images.unsplash.com/photo-1638454909775-82b870c6580d?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=387&q=80
copyright_author: 飞儿
copyright_url: 'https://www.nesxc.com/post/hexocc.html'
license: CC BY-NC-SA 4.0
license_url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/'
abbrlink: 2071449193
date: 2021-12-13 00:13:37
---

* 项目时间： 2020年10月
* 项目背景： 慕课网的项目学习时做的笔记
* 项目记录篇，比较啰嗦

## 去哪儿项目记录梳理 ##

Axios--进行Ajax数据的获取

Vue Router--来做多页面之间的路由

Vuex--来做各个组件之间的数据共享

异步组件--来让我们代码上线，性能更优

Stylus--编写前端的样式

递归组件--实现组件调用自己的效果

插件--比Swiper插件来实现页面上的轮播效果

### 6-1  Vue项目预热-环境配置 ###

1. ##### cmd输入git --version报错解决办法： #####

①配置环境变量(分行已经是代表分号【;】间隔了)；

②安装的时候选择git和cmd一起的选项…(自动帮你配置好环境变量)

<img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif" alt="clipboard.png" style="zoom:50%;" />

2. ##### 打通线上(git码云)-线下……SSH公钥： #####

   + 设置->SSH公钥->生成/添加SSH公钥

   + 在Git Bash(在windows小型的Linux操作系统)运行Linux命令：

     ```
     ssh-keygen -t rsa -C "2211016493@qq.com" cat ~/.ssh/id_rsa.pub
     ```

   + 生成公钥粘贴到网站上,[网站上有公钥，然后其实本地有一个私钥，公钥和私钥做匹配]

3. ##### git码云克隆/下载->SSH复制 #####

   + Git Bash：cd切换到想要把代码存放的地方
   + git clone SSH复制的内容

4. ##### 创建一个Vue项目 #####

   + 大型项目Vue.js是不够的，需要使用命令行工具(CLI)：

   + 全局安装vue-cli

     ```
     npm install --global vue-cli 
     ```

   + 安装依赖

     ```
     # 创建一个基于webpack模板的新项目(my-project是你的项目文件夹名字)
     vue init webpack my-project   （这是基于cli2的创建项目的做法）
     standardlone√，vue-router√，ESLint√，ESLint Standard√，unit×，e2e×，use NPM√
     cd my-project
      npm run dev
     ```

### 6-3  Vue项目预热-项目代码介绍 ###

+ 路由的配置都放在router文件夹的index.js里面;路由就是根据网址的不同，返回不同的内容给用户

+ APP.vue是整个应用的根组件，在APP.vue里<router-view>显示的内容就是当前路由地址所对应的路由内容，

  ```
  export default new Router(
  	{  routes:[
  		{path: '/',
  		 name: 'HelloWorld', 
  		 component: HelloWorld   
  		}] 
  	}
  )
  ```

+ 路由内容在router文件夹的index.js配置项找到，当访问根路径的时候(path:'/')，展示的是HelloWorld单文件组件。

+ import Home from '@/pages/home/Home.vue'  @表示src目录下，Home.vue不写后缀.vue也会帮你去找到它

### 6-4  Vue项目预热-单文件组件与Vue中的路由 ###

5. ##### Vue中做页面跳转一般不用a标签，用： #####

   ```
   <router-link to="/list" class="home">列表页</router-link>
   ```

6. ##### template模板只能向外暴露一个根标签 #####

   所以里面的内容必须有一个div进行包裹

7. ##### 【**多页面应用**】：页面跳转→返回HTML #####

   + 特点：打开项目页面，点开控制台里的network，选择Doc,选择刷新页面。当访问首页的时候，会请求一个首页的html文件。进入列表页面，又会返回城市列表的页面html(没有home的html)。

     每次页面跳转的时候，后台都会给我们返回一个新的html文档。这种类型的网站就叫做**多页面应用**

   + 优点：

     + 首屏时间快
       首屏时间：页面首个屏幕内容展现出来的时间，为什么会快呢？访问一个页面的时候，服务器返回一个html。然后页面就会被展示出来，这个过程只经历了一个http请求，请求回来了页面也就展示出来了，所以页面展示的速度非常的快)

     + SEO效果好
       搜索引擎在做网页排名的时候需要知道网页的内容，才能给网页权重来进行网页的排名，搜索引擎可以识别html的内容，而我们网页所有的内容都放在html之中，所以SEO效果好

   + 缺点：

     + 页面切换慢
       每一次页面切换都需要发送一个http请求，假设网速比较慢的时候，页面来回切换会出现明显的卡顿

8. ##### 【**单页面应用**】：页面跳转→Js渲染 #####

   + 特点（前端路由渲染）

     第一次进入页面home的时候会请求一个html文件，从home(http://localhost:8081/#/)跳转list(http://localhost:8081/#/list)并没有不请求html文件，如何做到不请求html文件但是页面会跟着变呢？
     原理：JS会感知到url的变化，js动态地把当前页面内容清除掉再把下一个页面的内容挂载到页面上(把新的页面的DOM结构渲染出来)，这个时候路由不是后端来做而是前端，判断是显示哪一个组件把以前的组件清除掉就可以。这时候就不会每次跳转，都去请求页面了

   + 优点

     + 页面切换快：因为不请求→当页面之间做跳转不需要做html文件的请求，节约了很多http请求发送的时延，使页面切换的过程变得非常快

   + 缺点

     + 首屏时间稍慢
       单页首屏展示出来需要请求一次html，同时还需要发一个js的请求，2个请求都回来了首屏才会展示出来
     + SEO(搜索引擎优化)差
       搜索引擎认识html中的内容，不认识js的内容，单页页面所有内容都是靠JS渲染生成的，搜索引擎不识别这一块的内容，它就不给你的网页一个好的排名

9. ##### 有缺点为什么要使用Vue开发单页应用？ #####

   其实，Vue之中还提供了其他的技术(比如服务器端渲染这样的技术)，通过这些技术我们可以完美地解决单页应用的问题。解决了这些问题后，实际上单页应用对前端来说是一套非常完美的解决方案。

### 6-5  Vue项目预热-项目代码初始化 ###

11. ##### 添加第二行代码：在移动端的设备，用户用手指放大缩小是无效的，页面的比例始终是1:1 #####

    ```
    <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    ```

12. ##### reset.css(重置页面的样式表) #####

    不同的手机浏览器上默认的样式是不统一的，把初始化样式作一个统一。

13. ##### border.css：该文件可以收藏起来以后直接用 #####

    + 解决移动端1像素边框问题
      border-bottom:1px solid green,指的是css像素。有的手机屏幕分辨率比较高，它是一个2倍屏或者3倍屏。在2倍屏实际上不是1个物理像素的高度，可能是2个或者3个物理像素的高度。为了解决多倍屏中一像素边框会被显示成多倍屏的问题。

    + 项目入口文件main.js里面引入：

      ```
      import './assets/styles/reset.css'
      import './assets/styles/border.css'
      ```

14. ##### 引入fastClick库，解决移动端300毫秒延迟的问题 #####

    + 在移动端开发中，某些机型某些浏览器上使用click事件时会延迟300ms才执行

    + 把fastclick安装到项目的依赖中，（package.json中的"dependencies"）

      ```
      npm install fastclick --save　
      save意思是不管在开发环境或者是打包生成线上版本的代码都需要使用fastclick
      ```

    + 在main.js里面

      ```
      import fastClick from 'fastclick'
      fastClick.attach(document.body)
      //attach是fastClick自带的方法 　
      ```

15. ##### iconfont：创建一个项目-Travel项目图标 #####

16. ##### git的使用 #####

    ```
     git add.     //把本地的修改提交到git的缓存区
     git commit -m 'project init' //把缓冲区的内容提交到本地仓库(线上的代码还没有任何改变)
     git push     //把本地仓库的代码推到线上去，git码云官网代码更新 
    ```

### 7-1  Vue项目首页-header区域开发 ###

![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image016.gif)

18. 【CSS 预处理器】定义了一种新的语言，其基本思想是，用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行 CSS 的编码工作。转化成通俗易懂的话来说就是“用一种专门的编程语言，进行 Web 页面样式设计，再通过编译器转化为正常的 CSS 文件，以供项目使用”。
    https://www.cnblogs.com/yanxiaoge/p/11078843.html

CSS预处理器的出现大大的提高了前端开发的效率和逼格，它让CSS可编程化。LESS和Sass/SCSS/Stylus是为常见的预处理器。

+ 安装stylus依赖包 npm install  stylus --save  （0.54.5）

+ 安装stylus-loader npm install stylus-loader --save  （3.0.1）

+ 重新启动项目 npm run start

  用stylus来写样式,scoped限制只对当前组件有效，在这个组件中写的样式不对其他组件产生影响：

  ```
  <style lang="stylus" scoped></style>
  ```

19. 移动端的布局一般采用rem的布局方式

reset.css的html里font-size设置成了50px，rem是相对与50px的这个尺寸，设计师给的是2倍尺寸的图片，86px应该写成43px，1rem=html的font-size=50px，那么43px=.86rem。

### 7-2  Vue项目首页-iconfont的使用和代码优化 ###

21. 定义一个伪类实现[倒三角形]：

    ```
     <div class="nabla"></div>
     .nabla{ 
      width:0; height: 0px; 
      border-top:10px solid black; 
      border-left:10px solid white; 
      border-right:10px solid white; 
      }
    ```

![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif)

22. iconfont的使用

①官网下载

②下载的文件压缩包中需要使用的文件

![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image006.gif)

③修改iconfont.css文件

![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image010.gif)

![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image012.gif)

```
iconfont.css最后位置有提供一些类，汉语拼音的形式的类，我们可以通过64位或者16进制的一个码来直接使用这些图标(官网上复制代码)  
.icon-jiantou:before{content:"\e64a"}  
.icon-fanhui  ..icon--sousou
```

④main.js引入iconfont.css：import './assets/styles/iconfont.css'

23. 代码的优化：

    + varibles.styl。background:#00bcd4，整个网页地方很多用到这个颜色(主题颜色)，#00bcd4用一个变量来表示，如果以后想要改变网页的主题，只要改变那个变量，全局就可以跟着改变，可维护性可以得到非常大的提升。

      + src/assets/styles下创建一个文件varibles.styl：$bgColor=#00bcd4
      + 在style标签里引入：@import '../../../assets/styles/varibles.styl'   
            background:$bgColor

    + 对 [ 多处import '../../../assets/styles/varibles.styl' ] 长路径的优化

      + 打开build目录>-webpack.base.conf.js>-添加对应的代码(@可以代替src使用的意思)
        <img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image014.gif" alt="clipboard.png" style="zoom:67%;" />

      + 此时，@import '~@/assets/styles/varibles.styl'，注意：

        如果在CSS中引入其他的CSS，使用【@】符号需要在前面加【~】符号。
        Header.vue的<style></style>里示例：@import '~styles/varibles.styl'

        main.js示例：import 'styles/reset.css'

### 7-3  Vue项目首页-首页轮播图 ###

![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image040.gif)

24. ##### 建立git分支--【index-swiper】 #####

    在企业开发当中每创建一个新的功能需要新建一个git分支来进行代码的开发，代码开发完成把分支上的代码合并到master主分支上。

    ```
    先切换目录至项目文件夹 cd xxx
    git码云网新建分支【index-swiper】
    把线上的分支拉到本地 git pull
    git checkout index-swiper    切换到index-swiper分支进行代码的开发 
    ```

    ```
    git status 命令用于显示工作目录和暂存区的状态.使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被Git tracked到。
    git log.   git status不显示已经commit到项目历史中去的信息。看项目历史的信息要使用
    ```

25. ##### 制作轮播图借助第三方插件——vue-awesome-swiper（github搜索） #####

    + 安装 ：npm install vue-awesome-swiper@2.6.7 --save

    + 引入：入口文件main.js

      ```
      import VueAwesomeSwiper from 'vue-awesome-swiper'
      Vue.use(VueAwesomeSwiper)
      import 'swiper/dist/css/swiper.css'
      ```

    + src/pages/home/components创建Swiper.vue……

    + Swiper.vue组件里（原本github上面的代码）
      <img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image020.gif" alt="clipboard.png" style="zoom:67%;" />

    + 在Swiper.vue组件里定义这个数据：

      ```
      data () {   
        return {    
      	swiperOption: {}    
        }
      }
      ```

    + 在Home组件中引入、注册、使用

+ ##### 根据需求，对Swiper组件作修改 #####

  + 删除轮播图的左右箭头div（swiper-button-prev和swiper-button-next）

  + 删除灰色滚动条div（swiper-scrollbar）

  + 删除文字、插入图片：

    ```
    <swiper-slide>
      	<img class="swiper-img" src="http://mp-piao-admincp.qunarzz.com/mp_piao_admin_mp_piao_admin/admin/20191/37a42ce34dc16cd43bad17570bf6ab31.jpg_750x200_65d24bd7.jpg" />
    </swiper-slide>   
    <swiper-slide>
      		<img class="swiper-img" src="http://img1.qunarzz.com/piao/fusion/1811/31/da037478f37cf202.jpg_750x200_fe28d396.jpg" />
    </swiper-slide>
    ```

  + 对图片宽高进行调整：

    ```
    .swiper-img       width:100% 
    ```

+ 调整代码：Home.vue插入test的div

  ```
  <template> 
      <div>   
      	<home-header></home-header>   
          <home-swiper></home-swiper>   
      <div>test·······</div> 
      </div> 
  </template>
  ```

  ##### F12的network改成fast 3G，刷新页面test文本有明显的抖动 #####

  [原因]：图片没有加载的时候高度是0，test在图片位置。图片加载完了才把图片撑开，test才跑到图片下面

  [解决]：<swiper></swiper>外层加一个div标签wrapper，设置样式如下：

  ```
  .wrapper   
  	overflow:hidden   
  	width:100%   
  	height:0   
  	padding-bottom:26.67%   
  	background: #eee   //图片大小是375(W)×100(H)   //100/375≈26.67%
   注：height:26.67%是错的，相对的不是width的26.67%，而是父级元素的26.67%。
  
  也可以这样写(但可能有些浏览器的兼容性有问题)：
  .wrapper  width:100%  height:26.67vw
  ```

  解决后，test一直在那个位置，没有抖动

+ ##### 添加轮播图的点 #####

  + 加一个配置项，传swiper-pagination进去
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image022.gif)

  + ##### 把轮播图的点改成白色无效 , #####

    （swiperOption 是传递给swiper组件的options里的，Swiper内部拿到这些数据，改变样式）

    ```
    .swiper-pagination-bullet-active     
    	background:#fff!important
    ```

  + ##### 解决办法：把轮播图的点改成白色有效  （样式穿透，不受scoped限制） #####

    .wrapper所有子组件只要出现.swiper-pagination-bullet-active  变成白色
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image024.gif)

☐ 思考：

用了<swiper></swiper>，可以理解成第三方组件，实际上是通过slot插槽的形式把页面具体的数据传给swiper

slot插槽：有的时候我们在用组件的时候，我们希望组件的一部分内容可以被父组件去定制的时候，采用slot形式往组件里传递可以被自己定制的内容

![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image026.gif)

 + 修改代码使轮播图的图片循环输出：loop：true
   ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image028.gif)

26. Git的使用——分支内容提交&合并

    + 把本地index-swiper分支的内容提交到了线上index-swiper分支      index-swiper -> index-swiper
      ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image034.gif)

    + 把index-swiper分支的内容合并到master分支：

    + 切换到master分支：  git checkout master  ;  

    + 把index-swiper分支新增的内容合并到本地的master分支：  git merge origin/index-swiper

      ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image036.gif)

    + 最后git push把本地的master分支的内容提交到线上

      ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image038.gif)

### 7-4  Vue项目首页-图标区域页面布局 ###

27. ##### 新建【index-icons分支】 #####

28. src/pages/home/components文件夹创建Icons.vue

导出组件→Home引入、注册组件→<home-icons></home-icons>
![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image046.gif)

29. ##### 先实现一个小图标占位 #####

    ```
    .icons   
    	overflow:hidden   
    	height:0   
    	padding-bottom:50%   
      .icon    
    	float:left    
    	width:25%    
    	padding-bottom:25%
    ```

    + 图标区域布局：

      ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image042.gif)

    ```
        overflow:hidden      
        height:0      
        padding-bottom:50%  
    相当于：      
    	overflow:hidden      
    	width:100%      
    	height:0      
    	padding-bottom:50%
    ```

+ 小图标布局
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image044.gif)

```
.icon     
	float:left     
	width:25%     
	padding-bottom:25%
```

+ 布局问题：
  + 图片放上去太大：.icon→overflow:hidden→给<img>一个div→.icon-image-content [ height:100% ]
  + img+p超过高度50%：.icon>-height:0
  + 图片居中：.icon-img-content [ display:block;margin:0 auto ]
  + 间距：.icon-img [ box-sizing:border-box;padding:.1rem ]
  + box-sizing:border-box，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。
  + 字体颜色：$darkTextColor=#333→@import '~styles/varibles.styl';

|                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image048.gif) | ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image050.gif) |

### 7-5  Vue项目首页-图标区域逻辑实现 ###

| ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image064.gif) | ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image066.gif) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |

30. ##### Swiper组件实现区域图标轮播：需求：两层图标只有上面一层轮播，实现上下两层图标都可以轮播 #####

（原来icons的overflow:hidden去掉，因为swiper-container自带overflow）

 .icons >>> .swiper-container   height:0   padding-bottom:50%

```
<template>    
    <div class="icons">        
        <swiper>         
            <swiper-slide>             
                <div class="icon" v-for="item of iconList"  :key="item.id"> 
                	<div class='icon-img'>                 
                		<img class='icon-img-content' :src="item.imgUrl" />
                	</div>                 
            		<p class="icon-desc">{{item.desc}}</p>             
            	</div>         
           	</swiper-slide>        
        </swiper>    
    </div> 
</template>
```

31. ##### 实现图片循环写法: #####

<img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image052.gif" alt="clipboard.png" style="zoom:67%;" />

32. ##### 一个页面8个图标，实现第九个图标开始轮播 #####

使用【计算属性computed】实现：

+ 不需要循环变更数据，key值可以写index，div循环的不是iconList了，是page
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image054.gif)
+ index=8时代表第九个图标(一个页面8个图标)，page=1，表示在第二页  
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image056.gif)

33. ##### 代码优化：当图标下面的文字过长显示省略号… #####

| ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image058.gif) | ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image060.gif) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image062.gif) |                                                              |

34. Git—分支内容提交&合并

### 7-6  Vue项目首页-热销推荐组件开发 ###

<img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image084.gif" alt="clipboard.png" style="zoom: 67%;" />

35. 新建[index-recommend分支]

36. 新建recommend.vue文件→export导出→Home.vue引入import

37. <img>宽和高定死的话不用外层包裹div

38. <li></li>下面使用【1像素边框】：

    li标签加上类：  border-bottom  （之前引入了scr/assets/styles/border.css）
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image068.gif)

    ```
    @import '~styles/mixins.styl';
    ```

    + 省略号显示：光用ellipsis()还不行，接下面min-width:0技巧实现

|                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image076.gif)<br />![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image074.gif) | <img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image078.gif" alt="clipboard.png" style="zoom:150%;" /> |

39. 实现热销推荐三个<li></li>循环：

| ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image080.gif) |
| ------------------------------------------------------------ |
| ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image082.gif) |

### 7-7  Vue项目首页-开发周末游组件 ###

![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image088.gif)

41. 新建Weekend.vue

l 复制Recommend.vue的内容进行修改→导出export→Home.vue引入

42. 修改： 要在<img />外面包裹一层div，不给图片具体的宽、高，而是width:100%

    删除flex布局，删除查看详情按钮，相应的缩进修改

43. 见**7-3Vue****项目首页-首页轮播图**的思考：slot插槽

44. 不小心先push到了master分支解决办法：

    ```
    首先在主分支上执行： git log  
    找到你想要同步的commit的ID，切换到分支以后执行
    git cherry-pick 56aec3410629347fefb5cfd918be32be6fb52e78
    git push
    ```

    ```
    git branch     查看所有分支
    git merge xxx   让新分支与xxx分支合并
    ```

![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image086.gif)

### 7-8  Vue项目首页-使用axios发送ajax请求 ###

45. ##### 创建【index-ajax分支】 #####

46. 在Vue中发送ajax有很多工具可以供我们使用，浏览器自带的fetch函数、vue以前推荐的vue-resource，Vue官方推荐我们使用axios第三方模块，axios非常强大，可以实现跨平台的数据请求，比如你在浏览器端axios可以帮助你发送SHR的请求，在node服务器上可以帮助你发送http请求。

47. ##### 安装axios  ：npm install axios --save  （0.17.1） #####

48. 整个首页发一个ajax请求，把ajax的代码写在Home.vue，可以把数据传给子组件。

    ```
    <template> 
      <div>   
    	<home-header></home-header>   
    	<home-swiper></home-swiper>   
    	<home-icons></home-icons>   
    	<home-recommend></home-recommend>   
    	<home-weekend></home-weekend> 
      </div> 
    </template> 
    <script> 
    import HomeHeader from './components/Header' 
    import HomeSwiper from './components/Swiper' 
    import HomeIcons from './components/Icons' 
    import HomeRecommend from './components/Recommend' 
    import HomeWeekend from './components/Weekend' 
    import axios from 'axios' 
    export default {  
    name: 'Home',  
    components: {   
    HomeHeader,   HomeSwiper,   HomeIcons,   HomeRecommend,   HomeWeekend  },  
    methods: {   
    	getHomeInfo(){axios.get('/static/mock/index.json').then(this.getHomeInfoSucc)},   
    	getHomeInfoSucc (res) {console.log(res)}},  
    	mounted () {this.getHomeInfo()}} 
    </script> 
    ```

    + axios返回的结果是一个promise对象，this.getHomeInfoSucc
    + mounted () { this.getHomeInfo() }：页面一挂载完成就请求ajax的数据，数据获取成功把数据打印出来

+ static存放的是静态文件，创建一个mock文件夹，放index.json，把数据放到static是因为整个工程里面只有static目录下的内容可以被外部访问到

| ↓↓可以访问↓↓                                                 | ↓↓main.js不可以访问，会自动重新定位回到首↓↓                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image090.gif) | ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image092.gif) |

【本地开发的模拟数据】不提交到线上：

+ .gitignore文件中添加：static/mock     static/mock这样这个文件夹就不会被提交的线上的git仓库，也不会提交到本地的git仓库
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image094.gif)

【本地开发的模拟数据】

+ 问题：  /static/mock/index.json现在用的都是本地模拟接口地址，假如代码要上线，不能填成这样的地址，需要在上线之前把地址改成 ‘/api/index.json’ 这种格式，上线之前改动代码有风险，不建议这样操作。
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image096.gif)
+ 解决：  如果有一个转发机制，它可以帮助我们把对api下所有json文件的请求转发到本地的static/mock文件夹下，这样就可以了。Vue有提供Proxy代理的功能，通过这个功能可以实现这个构想。
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image098.gif)

+ 如图配置：  当我们请求api这个目录的时候，我们希望它去把请求转发到服务器8080端口，路径作一个替换：一旦请求的地址是以api开头的，那么就替换请求到本地/static/mock(在开发环境里，Vue的脚手架工具会自动帮助你把api进行替换，即作一个开发环境的转发)    
  + 实际上这个功能不是Vue提供的，是webpack-dev-server这个工具提供的(了解即可) 
  + 改变了配置项文件需要重启服务器

【模拟数据的具体数据】： index.json
![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image100.gif)

+ "ret": true  --服务器正确响应了你的请求
+ 控制台有ajax返回值，ajax数据获取成功
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image102.gif)
+ **细节点：**写json文件的时候如果最后数据末尾多加逗号【,】，这有可能导致json格式解析失败
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image104.gif)

### 7-9  Vue项目首页-首页父子组组件间传值 ###

上一节从ajax的接口获取到了首页的数据，要把这些数据分别传给首页的各个组件：
![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image108.gif)

删除原来直接写上去的数据，父组件将数据传过去

53. ##### 问题解决：Header轮播图默认显示的图片是最后一张 #####

    + [原因]：使用swiper页面还没获取ajax的时候，这时props接收的数据是外部的空数组，swiperList最初创建的时候是通过空数组创建的，然后当ajax数据获取完成之后，swiperList变成真正的数据项，再传给home-swiper这个组件的时候它才获取到新的数据，然后重新渲染新数据对应的很多轮播的图片。

    + [解决]：swiper初次创建由完整的来创建而不是空数组来创建。(当传递过来的list是空数组，v-if的值是false，swiper不会被创建；真正数据过来了swiper才会被创建)
      ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image120.gif)

    + 在模板里面尽量避免出现逻辑型的代码→computed属性：

      ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image124.gif)![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image122.gif)

+ ##### 需求改进： Icons轮播图在页面自动左右滚动，使轮播图不自动滚动的实现如下： #####

  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image126.gif)![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image128.gif)

### 8-1  Vue项目城市选择页-路由配置 ###

54. 新建新分支：【city-router】，配置路由index.js

    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image130.gif)

+ 创建city组件

  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image132.gif)

55. 路由跳转

    + 点击首页的[北京]可以跳转City.vue  (做页面跳转的内置组件router-link)

    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image134.gif)

    + 点击首页的[北京]跳转页面，北京变成了灰色，是因为默认点击后加a标签。  处理成字体的颜色是白色
      ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image136.gif)  

56. ##### 做城市选择的Header.vue #####

    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image142.gif)

    + 创建 、City.vue中import→export default注册，使用
    + 返回图标的制作：做一个[绝对定位]显示出来
    + 点击实现回到首页(<router-link to="/"></router-link>)(回到根路径也就是首页)

+ 代码的优化

```
@import '~styles/varibles.styl'  
height:$headerHeight；
line-height:$headerHeight  
/home/components/Header里面的 height 和 line-height 也替换掉  
好处：改动所有页面的页头跟着变
```

* 提交到git仓库

### 8-2  Vue项目城市选择页-搜索框布局 ###

新建git分支：【city-search】

做Search.vue，新建导入注册使用

* 细节：让搜索框里面文字很长的时候文字不要紧贴搜索框两侧：

  ```
  写padding要加box-sizing:border-box
  ```

  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image144.gif)

* 代码提交到git仓库

### 8-3  Vue项目城市选择页-列表布局 ###

+ 准备：

  + 新建git分支：【city-list】

  + /city创建组件List.vue(→组件起名name:CityList)

  + 官网的列表是借助浏览器的自带的滚轮实现的列表，我们希望引入更高级的关于区块滚动的内容Better-scroll

  + div加上上下边框的class：border-topbottom，(border-topbottom是border.css里面的)

  + 原来的上下边框颜色比较浅，修改样式【控制页面上显示的1像素边框的颜色】：

    ```
    .border-topbottom   
      &:before    
     	border-color:#ccc   
      &:after    
     	border-color:#ccc
     意思是：border-topbottom这个类:before和:after伪元素的border-color都设成#ccc
    ```

  + .button-list→.button-wrapper→.button（城市button外面还要有div,进行包裹）

  + 这样城市button没有显示出来，因为  .button-wrapper设置了float，要给.button-list加上overflow:hidden触发它的BFC     https://blog.csdn.net/ty987654/article/details/77863473
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image146.gif)

+ 注意button-list右边留出padding给ABCDEFG…
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image148.gif)

+ Header和Search框不见了，因为没有设置overflow:hidden，多出去的高度会撑出去

| <img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image150.gif" alt="clipboard.png" style="zoom:150%;" /> | <img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image152.gif" alt="clipboard.png" style="zoom:80%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ●Header和Search出来了↓                                       |                                                              |
| ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image154.gif) | <img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image156.gif" alt="clipboard.png" style="zoom:80%;" /> |
| ●撑出来的部分是超过list区域的内容                            | ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image158.gif) |
| ●加上overflow:hidden，看起来没有问题了，但是不能往下拖，只能显示这样一部城市列表↓ | 下节课会对这个区域使用Better-scroll的插件，可以让这个区域的滚动很类似于原生APP的拖拽效果，会非常酷炫 |
| <img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image160.gif" alt="clipboard.png" style="zoom:200%;" /> | <img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image162.gif" alt="clipboard.png" style="zoom:67%;" /> |

### 8-4  Vue项目城市选择页-BetterScroll的使用和字母表布局 ###

<img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image174.gif" alt="clipboard.png" style="zoom:50%;" />

+ 准备：

  + github搜索第三方的包--BetterScroll(iscroll的一个封装，BetterScroll使用起来更加友好)

    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image164.gif)

  + 安装 npm install better-scroll --save  （1.8.1）

+ 使用BetterScroll--制作完成可以往下拉列表，而且拉到尽头会有回弹的效果。官方文档使用说明：
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image166.gif)

  + 使用条件：需要符合上面这样的DOM结构：加多一个div把多个area内容包裹起来——list的div里面一个大的div

  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image168.gif)

+ 使用方法：

  + 首先要引入Better Scroll，  然后创建一个BetterScroll的实例，  BetterScroll实例创建的时候要接收一个DOM元素或者一个DOM的选择器，ref可以帮助我们获取DOM
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image170.gif)

  + 具体操作：导入，写一个生命周期函数：mounted会在页面挂载完毕执行， 创建一个scroll的实例属性=new  Bscroll(),同时把this.$refs.wrapper传入进去
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image172.gif)

+ 制作右侧字母表：

  + 在src/pages/city/components单独创建一个组件Alphabet.vue，导入注册使用

  + 布局：

    ```
    <template>  
      <ul class="list">    
        <li class="item">A</li>    
        <li class="item">A</li>    
        <li class="item">A</li>   
        <li class="item">A</li>    
        <li class="item">A</li>    
        <li class="item">A</li>    
        <li class="item">A</li>   
      </ul>  
    </template>
    <style lang="stylus" scoped>   
    @import '~styles/varibles.styl'   
    .list    
        display:flex    
        flex-direction:column    
        justify-content:center    
        position:absolute    
        top:1.58rem    
        right:0    
        bottom:0    
        width:.4rem    
    .item    
        line-height:.4rem     
        text-align:center     
        color:$bgColor  
    </style>
    ```

  + ‘finish city css’，提交代码到git

### 8-5  Vue项目城市选择页-页面的动态数据渲染 ###

<img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image192.gif" alt="clipboard.png" style="zoom:50%;" />

* 准备工作：

  + 新建git分支：【city-ajax】

  + 准备好city.json文件放到static/mock目录

  + 放在最外层组件—City.vue来做，一次ajax就可以获得这个页面所有组件的内容

    ```
    <script> 
    import axios from 'axios' import CityHeader from './components/Header' import CitySearch from './components/Search' import CityList from './components/List' import CityAlphabet from './components/Alphabet' 
    export default {   
        name: 'City',   
        components: {CityHeader,CitySearch,CityList,CityAlphabet},   
        data () {return {cities: {},hotCities: []}},   
        methods: {     
        	getCityInfo () { axios.get('/api/city.json')         .then(this.handleGetCityInfoSucc)},     
                handleGetCityInfoSucc (res) { 
                res = res.data 
                if (res.ret && res.data) {
                const data = res.data 
                this.cities = data.cities
                this.hotCities = data.hotCities}}},   
       	 	mounted () {this.getCityInfo()}} 
    </script>
    ```

  + 可以先console.log(res)看页面控制台接收到的模拟数据的内容

    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image178.gif)

  + 接收到数据就可以来做动态数据的渲染了：写完之后就需要把根组件的数据传给子组件

    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image180.gif)

  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image182.gif)

+ 注意细节: ，ABCDE…Z

  + cities不是一个数组，是一个对象 。这个对象比如键A，它的属性值是所有开头的城市的名字的集合。所以我们还要对他进行二次遍历。才能依次取出对应的城市

  + 对象的v-for循环是：v-for="(item,key) of cities ，不是v-for="(item,index) of cities。{{key}}代表ABCDE…Z  ，指的是键值对中的键

  + 二次循环：v-for="innerItem of item"。

  + 双重循环的key值  父级的key值等于key就可以，因为key是ABCDE…Z，不会重名，用key比较安全；如果父级的key值和子级的key值重名了也没有关系，只要这一层级的key值不重复就可以

    ```
    <div class="area" v-for="(item,key) of cities" :key="key">
    ```

  ```
  <div class="area" v-for="(item,key) of cities" :key="key">      
    <div class="title border-topbottom">{{key}}</div>      
    <div class="item-list">       
       <div class="item border-bottom"v-for="innerItem of item" :key="innerItem.id" >          {{innerItem.name}}       
       </div>      
    </div>     
  </div>
  ```

+ 右侧ABCDE…Z字母表：在Alphabet组件中，循环出来的是key，因为只要字母

  ```
  <template>   
    <ul class="list">    
      <li class="item" v-for="(item,key) of cities" :key="key">     
         {{key}}    
      </li>   
    </ul>  
  </template>
  ```

+ 代码提交到git

### 8-6  Vue项目城市选择页-兄弟组件数据传递 ###

新建git分支：【city-components】

+ #### 需求：希望点击右边的字母表，左侧的页面城市列表可以自动滚动到显示区域 ####

+ Alphabet.vue：绑定一个click事件，对应的方法：

  ```
  methods: {    
    handleLetterClick (e) {     
    	this.$emit('change', e.target.innerText)    //e是事件对象
    	},
  }
  ```

+ 希望把这个字母传递给List.vue组件，然后List对应的区块显示出来：  需要做一个兄弟组件的传值（非父子组件，以前讲过bus总线的形式），因为非父子组件非常简单，它们就是兄弟组件，处理兄弟组件之间的传值也可以通过这种方式：  Alphabet.vue传递数据给City.vue组件→City.vue转发数据给List.vue

+ 在父组件City.vue中监听：拿到这个字母

  ```
  @change="handleLetterChange"       
  handleLetterChange (letter) 
    { 
  	this.letter = letter    
    }
  ```

+ City.vue把letter转发给List.vue：  父传子通过属性的方式传递   。List组件拿到这个值，并且List.vue监听到letter有变化进行对应区块的展示：  借助【侦听器watch】！！！！（重要）

  ```
  watch: {    
    letter () {     
      if (this.letter) {      
        const element = this.$refs.[this.letter][0]  
        this.scroll.scrollToElement(element)     
      }    
    }   
  }
  ```

  ```
   //BetterScroll组件里面用到的参数必须是DOM元素或者DOM选择器
   (×)const element = this.$refs[this.letter]     
   (√)const element = this.$refs[this.letter][0]
  ```

  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image202.gif)

##### 这个地方动态绑定ref非常关键：这是子组件能跳转到传过来字母所对应区域的关键一步，第二个关键点：才是跳转scrollToElement #####

* #### 需求：实现在字母表作上下拖拽时对应城市列表自动上下滚动 ####

  思路：  获得字母A距离顶部的高度ya，手指滑动的位置距离顶部的高度yb，作差即获得手指位置距离A的距离，再除以每个字母的高度就可以知道当前是第几个字母，然后取对应的字母触发事件给外部  

  + 首先绑定touch相关事件3个，开始，移动，结束
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image206.gif)

  + 希望handleTouchStart后再去做其他事情，在data定义一个标识类

    ```
    data () {    
      return {     
    	touchStatus: false    
    	}   
    }
    ```

  + 需要一个数组来存储第几个字母，

    ```
    computed: {    
      letters () {     
        const letters = []  
    //cities是一个对象不是一个数组，将他的每一项存储为一个数组
          for (let i in this.cities) {      
            letters.push(i)     
          }     
        return letters    
      }   
    }
    原来的v-for="(item,  key) of cities"  
    改成：v-for="item of letters"  ,我们不是循环cities的键了，而是letters了，
    因为letters里面刚好存的就是就是字母
    ```

  + 手指移动事件具体做的事：

    ```
    handleTouchStart () {     
      this.touchStatus = true    
    },    
    handleTouchMove (e) {   
    // 在handleTouchMove里面做的事情：判断手指滑动的是哪个字母，然后跟点击字母事件一样，都向外触发change事件，由父组件监听这个事件。所以点击和滑动的区别在于，获取字母的方式不一样，但是目的都是一样的，就是向外触发同一事件，并携带字母出去。
      if (this.touchStatus) {      
    	const startY = this.$refs['A'][0].offsetTop  
        // 事件对象里会有一个touches数组   -79是减掉header和搜索框的高度 
    	const touchY = e.touches[0].clientY - 79      
    	const index = Math.floor((touchY - startY) / 20)      
    	if (index >= 0 && index < this.letters.length) {       
    	   this.$emit('change', this.letters[index])      
    	}     
      }    
    },    
    handleTouchEnd () {     
    	this.touchStatus = false    
    }
    ```

  + **为Alphabet.vue绑定ref，**作用：是为了计算字母A距离顶部的高度，拿到offsetTop值
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image208.gif)

### 8-7  Vue项目城市选择页-列表性能优化 ###

+ #### 优化startY ####

  + this.startY的值其实是固定的，但每次执行函数都要算一遍，耗费性能
  + 在初次渲染Alaphabet组件的时候，cities的值还是空对象。当ajax数据获取后，往Alphabet传的数据发生变化，Alphabet这个组件就会重新渲染，
  + 当Alphabet重新渲染之后，updated这个生命周期钩子就会被执行，这个时候页面中已经展示出了城市列表的所有内容，这个时候就去获取A这个字母所在的DOM对应的offsetTop的值

  ```
    updated () {
      /* 当页面的数据完成了更新，并完成页面渲染后，执行这个钩子 */
      this.startY = this.$refs['A'][0].offsetTop
      //this.startY 
    },
  ```

+ #### 函数节流优化： ####

  手指在字母表上移动，函数执行的频率是非常高的。限制函数执行的频率

  ```
  解释节流函数：
  data里面定义一个timer，
   如果已经存在了就把this.timer去除掉：
      if (this.timer) {
       clearTimeout(this.timer)
     }
   否则创建一个timer：this.timer = setTimeout()
  如果你正在做这样一件事情的时候，让它延迟16ms再去执行，如果在这16ms之间你又做了手指的滚动那么会把上一次你要做的操作清除掉、重新执行你这次要做的事情。
  通过函数节流的方式，可以大大节约handleTouchMove执行的频率，从而提高网页的性能
  肉眼察觉不到，实际上性能大大提高
  ```

  ```
  handleTouchMove (e) {
        /* 当手指触摸的时候才去做的事 */
        if (this.touchStatus) {
          if (this.timer) {
            clearTimeout(this.timer)
          }
          this.timer = setTimeout(() => {
            const touchY = e.touches[0].clientY - 79
            const index = Math.floor((touchY - this.startY) / 20)
            if (index >= 0 && index < this.letters.length) {
              this.$emit('change', this.letters[index])
            }
          }, 16)
        }
      }
  ```

+ 代码提交到git，'performance'

### 8-8  Vue项目城市选择页-搜索逻辑实现 ###

+ ##### 需求：实现搜索城市名字或拼音把对应的城市名字显示出来 #####

+ 新建git分支：【city-search】

  ```
  <template>
  <div>
    <div class="search">
      <input  class="search-input" type="text"
              placeholder="输入城市名或拼音"
              v-model="keyword">
              //这个地方的双向绑定，实现了有输入值的时候，List组件隐藏
    </div>
    <div class="search-conent"
          ref="search" //这个ref用于设置滚动效果
          v-show="  keyword">
      <ul>
        <li class="search-item border-bottom"
            v-for="item of list"
            :key="item.id"
            @click="handleCityClick(item.name)"
        >{{item.name}}</li>
        <li class="search-item border-bottom"
              v-show="hasNoData">
          没有找到匹配数据
        </li>
      </ul>
    </div>
  </div>
  </template>
  ```

  ```
  <script>
  import Bscroll from 'better-scroll'
  import { mapMutations } from 'vuex'
  export default {
    name: 'CitySearch',
    props: {
      cities: Object
    },
    data () {
      return {
        keyword: '',  //与搜素词做双向绑定
        list: [],
        timer: null
      }
    },
    computed: {
      hasNoData () {
        return !this.list.length
      }
    },
    watch: {
    //侦听器侦听keyword的改变：
      keyword () {
        if (this.timer) {
          clearTimeout(this.timer)
        }
        if (!this.keyword) {
          this.list = []
          return
        }
      //当keyword发生改变的时候，隔100ms箭头函数会被执行，
        this.timer = setTimeout(() => {
          const result = []
          for (let i in this.cities) {
     //json里面每一项都有spell(拼音)和name(中文)，有搜索到关键字对应城市名就添加到result之中
            this.cities[i].forEach((value) => {
              if (value.spell.indexOf(this.keyword) > -1 || value.name.indexOf(this.keyword) > -1) {
                result.push(value)
              }
            })
          }
          //所有匹配结果集合在result中，赋值给list，让他去显示
          this.list = result
        }, 100)
      }
    },
    updated () {
    //需要你传入一个DOM元素或者选择器→传search-content这个元素对应的ref：search
    //注意不需要整个全部滚动，只需要搜索结果滚动
      this.scroll = new Bscroll(this.$refs.search)
    },
    methods: {
      handleCityClick(city) {
        /* 此处组件可以直接调用commit方法 */
        /* this.$store.commit('changeCity', city) */
        this.changeCity(city)
        this.$router.push('/')
    },
      ...mapMutations(['changeCity'])
    }
  }
  </script>
  ```

+ 进一步修改样式：此时搜索框输入a，对应的内容很多，不能向下滚动看到所有匹配项，借助BetterScroll解决：
  <img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image216.gif" alt="clipboard.png" style="zoom:50%;" />

  + 问题：把a取消掉城市列表还在，解决：

    ```
    if (!this.keyword) { 
    	this.list = []  return //没有输入关键字，就让显示为空
    }
    ```

  + 当搜索框输入非匹配项，下面什么内容都没有，实现显示“没有找到匹配项”的文字：

    ```
    增加一个li标签：
    <li class="search-item border-bottom">没有找到匹配数据</li>
    ／／现在是无论找不找得到都显示”没有找到匹配数据“
    ```

    ```
    加上v-show来控制：
    <li class="search-item border-bottom" v-show="!length">没有找到匹配数据</li>
    length取反意思是如果list长度为0的时候才显示，
    现在是实现了找到的时候不显示+没找到显示+不搜索也显示,覆盖掉原来的所有城市列表
    search-content里面加上：v-show="keyword"，意思是keyword有值的时候才会显示li标签
    二者是不同时存在的
    ```

    + 模板里面尽量不要写逻辑运算，使用计算属性来优化(逻辑放到下面的js来完成)：

      ```
      <li class="search-item border-bottom" v-show="hasNoData">没有找到匹配数据</li>， 
      computed: {
        hasNoData () {return !this.list.length}
      }
      ```

+ 'search finish'代码提交到git

### 8-9  Vue项目城市选择页-Vuex实现数据共享 ###

#### 需求1：实现在城市选择页点击城市，首页变为对应的城市 ####

+ 创建新的git分支：【city-vuex】

+ 实现思路：City.vue和Home.vue没有公用的父级组件，这样就没有办法通过父级组件进行数据的中转，之前讲过bus总线的概念，在这里可以使用bus，但是使用bus依然比较麻烦，Vue的官方有提供一个工具——Vuex（Vue官方推荐的数据框架）。在Vue大型项目中，Vue只能承担视图层的主要内容，而当我们涉及大量数据之前传递时往往需要一个数据框架辅助，在Vue之中这个数据框架就是Vuex。

  + 当我们的一个项目之中各个页面或者多个组件之间进行复杂的数据传值很困难的时候，我们可以这样想，如果我们可以把这些数据放到公共的存储空间去存储，然后一个组件改变了这个公共的数据，其他的组件也能感知到，Vuex的设计理念是这样的

  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image218.gif)



+ 解读：虚线部分的内容就是公共数据存储的区域，把这个区域理解成store仓库，这个仓库由几部分组成：

  + 【State】：所有的公用数据都存储在State之中，那如果组件想用一个公用的数据，直接去调用State就可以了。有的时候我们希望改变State里的数据，不能让组件直接改变而必须走一个流程
  + 当有异步操作 或者一些比较多的逻辑操作，批量的同步操作时，放到Actions。组件先去调用Actions，Actions紧接着去调用Mutations，Mutations放的是一步一步对State的修改，当State存储的数据发生变化组件上显示的内容就会跟着变化了。
  + 有的时候我们也可以略过Actions(这一步不是绝对的)，让组件直接去调用Mutations修改State里面的数据，这块需要额外注意的是：
    + 当组件调用Actions时，调用的是Dispatch方法来操作Actions
    + 然后组件去调用Mutations或者Actions调用Mutations的时候，用commit方法来操作Mutations。

+ 使用Vuex ：

  + 安装: npm install vuex --save

  + src目录新建store/index.js， 引入

    ```
     import Vue from 'vue'  
     import Vuex from 'vuex'     
     Vue.use(Vuex)     
     export default new Vuex.Store({   
     	state: {city: '上海'},   //默认是上海
     	mutations: {
     	  changeCity (state, city) {     
     	    state.city = city  }   
     	  }  
     }) 
    ```

  + 在main.js里面：

    ```
    import store from './store/index'
    引入了store，
    创建根Vue实例的时候把store:store传进去(键和值一样写一个东西就行)
    ```

    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image220.gif)

+ 组件(home的Header.vue)的城市使用这个公用的数据：
  以前Home.vue的Header的城市数据是通过ajax后端返回给我们的，现在希望city是前端存储的不需要后端告诉，所以把原来的city代码删除。

  ```
  home的Header.vue的{{city}}改成
  {{this.$store.state.city}}   //此时Header的城市显示默认的上海
  //因为在main.js根实例把store传递进去了，紧接着Vuex创建的store会派发到每个子组件里面，所以每个子组件都可以用this.$store获取store
  ```

+ #### 需求2：城市选择页面中，点击热门城市的时候公用数据发生变化 ####

+ 实现思路：

+ 做法：

  + 为城市选择Citylist添加点击事件，当改变city的时候，派发changeCity这样一个Actions，把city作为第二个参数传过来。

    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image222.gif)

    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image224.gif)

  + 创建store的时候只有一个state，并没有actions，所以要在写一个actions对象

    ```
    actions: { 
    //这里对应的是那边dispatch的事件和参数
      changeCity (ctx, city) {     
    	 ctx.commit('changeCity', city)  
         //注意这里是context
         //之所以actions里面第一个参数是ctx，作用是可以借助ctx帮我们拿到commit方法
    	 }  
    }
    ```

  + actions里面已经接收到了传递过来的city，它需要调用Mutations去改变公用的数据，所以↓创建Mutations

    ```
    mutations: {    
      changeCity (state, city) {     
      	state.city = city    
      }   
    } 
    ```

  + 此时，通过Vuex实现首页和列表页的数据共享，点击热门城市，城市选择页的当前城市和首页的城市会显示对应的城市（但是要自行返回首页）

  + 其实这个过程并没有异步操作，没必要调用Actions去做一个转发，直接调用commit也是可以的。

    ```
    组件里：
    methods: {  
      handleCityClick (city) {     
        this.$store.commit('changeCity', city)
      }
    }
    store里：
    mutations: {    
      changeCity (state, city) {     
      	state.city = city    
      }   
    } 
    ```

+ #### 需求3：实现点击列表的时候也实现城市的切换 ####

  这跟需求1其实是类似的，监听、注意修改为innerItem.name，点击执行的都是一个方法
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image228.gif)

+ #### 需求4：实现搜索结果中点击城市也可以实现城市的切换： ####

  同样监听点击，然后执行的是同一个方法，只是不同的组件，传参名字不一样而已。这个地方需求1与需求3都是在list组件里，所以执行方法写一个就可以。Search组件没有，所以要赋值一下这个方法
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image230.gif)

+ ##### 需求1、需求2、需求4 ：都需要自行返回页面才能看见对应城市的显示，但是不会自行跳转页面 #####

  解决：【路由—编程式导航】在网页上做页面跳转，有2种方式：

  + 一种是通过a标签的形式实现跳转
  + 另一种是通过js中， window location.href这种形式。
  + 在Vue之中也一样，可以通过router-link这种标签的形式做页面的跳转，还可以通过js作js形式的跳转，js跳转不像window location.href这么简单，在vue-router里面用的是编程式的导航，编程式的导航提供给我们一个方法：$router.push(location, onComplete?, onAbort?)：

  + https://router.vuejs.org/zh/guide/essentials/navigation.html

  + 每个组件里都有实例属性router(在main.js里面根实例传了router)：

+ 点击城市的时候首先改变城市的内容，然后实现页面的跳转    this.$router.push('/')  '/'是首页地址
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image232.gif)

### 8-10  Vue项目城市选择页-Vuex的高级使用及localStorage ###

##### 问题：点击三亚城市变为三亚，刷新一次页面城市又回到了默认的上海。 #####

##### 需求1：希望实现选中过一次城市，下一次再访问网站的时候显示的是上次选择的城市 #####

+ 【引入localStorageAPI】：localStorage，HTML5提供的一个新的API，可以帮助我们实现类似cookie的功能，做到本地存储，这个API比cookie简单。

+ 更改：

  + 点击城市的时候不但把state.city改了，同时存一个 localStorage.city ，city的默认值是localStorage.city 或者 '上海' (优先从localStorage.city取，取不到才用上海)    

    ```
    export default new Vuex.Store({   
    	state: {    city: localStorage.city || '上海'   },   
    	mutations: {    
    		changeCity (state, city) { 
    		state.city = city     
    		localStorage.city = city    
    		}   
    	} 
    })
    ```

  + 建议只要用localStorage，就在外层包裹一层try catch，因为在某些浏览器，如果用户关闭了本地存储这样的功能或者使用隐身模式，使用localStorage可能会使浏览器直接抛出异常，整个代码就运行不了了
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image234.gif)

  + 对index.js进行抽离：
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image236.gif)
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image238.gif)
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image240.gif)

  + ##### 小问题：点击阿拉善盟，向下的箭头icon移位了 #####

    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image242.gif)

    ```
    home/Header.vue中：  (原来的width定死了)  原来：    
    .header-right     width:1.24rem     
    修改为：    
    .header-right     min-width:1.04rem     padding:0 .1rem    
    ```

    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image244.gif)

+ #### 对Vuex的进一步优化：映射 ####

  Vuex给了我们一个比较高级的API使得我们可以这样去写代码：    

  + ...mapState里可以传递一个数组，也可以是一个对象，  意思是想把Vuex里的city公用数据映射到这个组件的计算属性里，映射过来的名字叫currentCity
  + ...mapMutations     有一个Mutations叫changeCity，然后把这个mutation映射到组件里changeCity的方法里，     然后可以写成:this.changeCity(city)
  + ...mapGetters   getter的作用类似于组件中的computed计算属性的作用，当需要根据state里面的数据算出新的数据的时候就可以借助getter来提供新的数据，这样可以避免数据的冗余.组件使用之前要在computed里面做映射
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image250.gif)
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image254.gif)

  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image252.gif)

+ 【Module】
  当遇到非常复杂的业务场景，如管理后台系统的时候，经常有很多功能的数据在Vuex里进行存储，如果把mutations都放在mutations.js文件里，这个文件会慢慢变得非常庞大，难以维护，这个时候可以借助module对一个复杂的mutation state包括actions进行一个拆分。创建store的时候可以通过模块来创建，对各个模块的数据进行整合，通过module来写代码可以有更好的维护性。

![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image256.gif)

当然我们的项目中只有city一个公用数据，没必要使用module进行拆分。

+ ‘use vuex’代码提交带git

### 8-11  Vue项目城市选择页-使用keep-alive优化网页性能 ###

+ 新建git分支：【city-keepalive】

+ 问题分析：

| 1.换到城市选择页city.json请求了一次                          | ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image258.gif) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 2.返回到首页index.json也请求了一次                           | ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image260.gif) |
| 再进入城市选择页city.json又被请求一次，每一次路由发生变化时ajax都会被重新发送 | 原因：  每一次切换，组件都会被重新渲染，如home/Home.vue中 mounted () {    this.getHomeInfo()   },  mounted钩子会被重新执行，ajax数据就会被重新获取    <br /> 问题：每一次都获取数据性能很低，希望实现获取一次就可以了： |

+ 问题解决：

  1. APP.vue中：  <router-view/>显示的是路由所对应的内容，外层包裹keep-alive标签(是Vue自带的一个标签)。  意思是：路由的内容被加载过一次后把内容放到内存之中，下一次再进这个路由的时候不用重新渲染这个组件去执行钩子函数，只需要你进入内存里把以前的内容拿出来显示在页面上。
     此时，再进入城市列表页不会重复city.json，回到首页也是不会在index.json
     此时，实际上逻辑上存在问题：当在桂林的时候首页显示的是桂林的内容，切换到北京的时候首页应该显示北京的内容，所以城市改变的时候，首页还是需要重新加载ajax请求
     <img src="file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image262.gif" alt="clipboard.png" style="zoom: 67%;" />

  2. Home.vue中：请求接口时应带一个参数，等于Vuex里面存的当前的城市。所以，引入Vuex；

     ```
     import { mapState } from 'vuex'
     data () {    
         return { 
     
         //data里面设置一个数据lastCity，一开始值为空
         lastCity: '',     
         swiperList: [],     
         iconList: [],     
         recommendList: [],     
         weekendList: []    
        }   
     },
     computed: {    ...mapState(['city'])   }, //获取到对应城市的内容
     请求接口时应带一个参数：**（重要）**
     axios.get('api/index.json?city=' + this.city) //发ajax时把city放在请求里面
     //此时，首次进入页面mounted和activated都执行，当切换城市后只有activated执行，
     //所以借助这个生命周期函数实现：切换城市首页内容换成切换的城市的内容
     mounted () {  
     //当页面被挂载时，对第一次的城市做一个保存
     	this.getHomeInfo()   
     	this.lastCity = this.city
     }, 
     activated () { 
     //mounted被挂载的时候，页面初次加载时，会发ajax请求，页面重新显示时activated被重新执行，所以每次页面重新显示时判断页面和上次页面是否相同城市，如果城市不相等重新发一次ajax请求：
       if (this.lastCity !== this.city) { 
         this.lastCity = this.city   
         //重新发一次ajax请求
         this.getHomeInfo() 
       }   
     } 
     ```

+ 总结：

  + 通过keep-alive新增的一个生命周期函数activated，结合lastCity这个临时缓冲变量，实现网页性能优化的调整
  + 首页再次→城市选择页不会二次请求city.json
  + 城市没有发生变换返回首页不会二次index.json，城市变化返回首页才会二次index.json，同时数据参数是变化后的城市。

+ ‘finish page’代码提交到git分支。

### 9-1  Vue项目详情页-详情动态路由和banner布局 ###

+ 新建git分支：【detail-banner】

+ #### 需求1：点击跳转对应景点的详情页 ####

  + 代码： 注意将li标签改成router-link  添加to属性 为保持一致，修改tag属性为li

  ```
  <router-link :to="'/detail/' + item.id"   tag="li">  //配置路由信息   
    <li class="item border-bottom" v-for="item of list" :key="item.id">       
      <img class="item-img" :src="item.imgUrl" />      
      <div class="item-info">       
          <p class="item-title">{{item.title}}</p>       
          <p class="item-desc">{{item.desc}}</p>       
          <button class="item-button">查看详情</button>      
      </div>     
    </li>     
  </router-link>
  ```

  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image276.gif)
  景点文字会变颜色(router-link默认是a标签的颜色)，需要重新改样式

  + 修改路由配置
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image282.gif)

    ```
    :to="'/detail/' + item.id"
    
    //路径后面还会跟id这样的内容
    ```

+ 创建pages/detail/Detail.vue:  

  + 使用iconfont下载的zip(包含之前的图标和现在的图标)替换掉(iconfont.eot，iconfont.svg，iconfont.ttf，iconfont.woff四个文件)  
  + 注意iconfont.css的的data修改成新的
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image284.gif)

+ 修改Detail组件样式：
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image292.gif)

  ```
  .banner-img     width:100%  //使图片展示完全
  .banner-info     //实现渐变效果
  	display:flex     
  	position:absolute     
  	left:0     
  	right:0     
  	bottom:0     
  	line-height:.6rem     
  	color:#fff     
  	background-image: linear-gradient(top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.8))
  ```

### 9-2  Vue项目详情页-公用图片画廊组件拆分 ###

#### 需求：点击图片时展示图片轮播，下面显示图片轮播的页码 ####

+ 这种画廊组件在项目中可能不仅一个页面用到→变成一个公用的组件：创建common/gallary/Gallary.vue

+ ##### 公用组件Gallary： #####

  ```
  <template>
    <div class="container" @click = "handleGallaryClick">
      <!-- 对container绑定事件：希望点击轮播图，就会推出 -->
      <div class="wrapper">
        <swiper :options = "swiperOptions">
     <!-- swiper里面的每一页应该循环一些图片。去电swiper-slide，src写死，不要循环，找一张图片 -->
          <swiper-slide  v-for = "(item, index) in imgs" :key = index>
            <img class="gallary-img"   :src = 'item'/>
          </swiper-slide>
          <!-- 这样就有两张轮播图，是可以拖动的。但是下面还应该有反斜杠显示拖动的第第几张图片。
          所以还要加pagination.怎么配置pagination呢? swiper里面的pagination,注意要在data里面定义swiperOptions-->
          <div class="swiper-pagination" slot="pagination"></div>
      </swiper>
      </div>
    </div>
  </template>
  ```

  ```
  <script>
  export default {
    name: 'CommonGallary',
    // 图片是外面的数据传过来的
    props: {
      imgs:{
        type: Array,
        default() {
          return []
        }
      }
    },
    data(){
      return {
        swiperOptions:{
          // 在这里定义swiper里面的swiperOptions，没定义过是不能使用的
          pagination: '.swiper-pagination',
          // 底层是借助Swiper实现的，想知道怎么实现，去baidu搜索Swiper3的pagination官网。
          // 也可以查看Api官网,看左侧的pagination分页器。有一个paginationType.用第2种效果的fraction
          paginationType: "fraction",
          // 解决点击后轮播图问题：加两个参数observeParents
          // 意思是：Swiper插件只要监听到自己的元素或父级元素dom节点发生改变，就会自我刷新，就解决了宽度计算的问题
          observeParents: true,
          observer: true,
        }
      }
    },
    methods:{
      handleGallaryClick() {
        // 点击后出发事件
        this.$emit('close')
      }
    }
  </script>
  ```

  ```
  <style lang = stylus scoped>
  /* 解决swiper的container里有overflow：hidden问题 */
    .container >>> .swiper-container
      overflow: inherit
    .container
      display: flex
      position: fixed
      left: 0
      right: 0
      top: 0
      bottom: 0
      background: #000;
      z-index: 99
      flex-direction: column
      justify-content: center
      .wrapper
        background: #fff
        width: 100%   
        /*不给高度，而是撑开一个 正方形的位置*/
        height: 0
        /* overflow: hidden */
        padding-bottom: 100%
        .gallary-img
          width: 100%   解决图片太大的问题
        .swiper-pagination
        /* 让颜色是白色 */
          color: red  
          bottom: -1rem   
          /* 这样会页面没有页码了。此时去掉wrapper的overflow 依然不行，*/
          /* swiper-container上面默认是有overflow：hidden的内容，所以将高度限制死了 */
  </style>
  ```

+ ##### Banner.vue使用Gallary.vue公用组件 #####

  + common-gallary默认情况是隐藏的，点击画廊才显示出来。点击轮播，显示画廊

    ```
    <template>
      <div>
        <div class="banner" @click = "handleBannerClick" >
          <img :src="bannerImg"  alt="" class="banner-img">
          <div class="banner-info">
            <div class="banner-title">
              {{this.sightName}}
            </div>
            <div class="banner-number">
              <span class="iconfont banner-icon">&#xe632;</span>
             {{this.gallaryImgs.length}}
            </div>
          </div>
        </div>
        <!-- 我希望他的默认状态是隐藏的 -->
        <common-gallary :imgs = "gallaryImgs" 
                      v-show = "showGallary"
                      @close = "handleGallaryClose"
        >
        </common-gallary>
      </div>
    </template>
    
    <script>
    import CommonGallary from 'common/gallary/Gallary'
    export default {
      name: 'DetailBanner',
      components: {
        CommonGallary,
      },
      props: {
        sightName: {
          type: String,
        },
        bannerImg: {
          type: String,
        },
        gallaryImgs: {
          type: Array,
        }
      },
      data() {
        return {
          showGallary: false,
        // 默认是false不显示，当你点击的时候，显示
        }
      },
      methods:{
        handleBannerClick(){
          this.showGallary = true
          // 此时点击显示轮播图。但是此时轮播图页码又出现问题了。
          //原因：一开始让commonGallary隐藏，
          // 当再次显示的时候Swiper计算宽度会有问题，导致轮播图无法正常滚动，
          //解决：Gallary.vue的SwiperOptions参数设置。
          
        },
        handleGallaryClose() {
          this.showGallary = false
        }
      }
    }
    </script>
    
    <style lang = "stylus" scoped>
      .banner
        overflow: hidden
        position: relative
        height: 0
        padding-bottom: 55%
      .banner-img
        width: 100%
      .banner-info
        display: flex
        position: absolute
        left:0
        right: 0
        bottom 0
        line-height: .6rem
        color: #fff
        background-image: linear-gradient(top, rgba(0, 0, 0, .8))
        .banner-title
          flex:1
          font-size: .32rem
          padding: 0 .2rem
        .banner-number
          margin-top: .2rem
          padding: 0 .4rem
          height: .32rem
          line-height: .32rem
          border-radius: .2rem
          background: rgba(0, 0, 0, .8)
          font-size: .24rem
          .banner-icon
            font-size: .24rem
    </style>
    ```

    





115.

l 传imgs：

| Banner.vue中：   | <common-gallary    :imgs="imgs"    >    </common-gallary>    |
| ---------------- | ------------------------------------------------------------ |
| data里面定义imgs | data () {    return {     imgs: ['http://img1.qunarzz.com/sight/p0/1907/39/394802bd7fce909fa3.img.jpg_r_800x800_250e62f4.jpg', 'http://img1.qunarzz.com/sight/p0/1907/3d/3deee24945b577b3a3.img.jpg_r_800x800_46dee719.jpg']    }   }, |

+ 'banner finish'代码提交到git分支

### 9-3  Vue项目详情页-实现Header渐隐渐显效果 ###

+ #### 需求：详情页左上方有返回按钮，往下滑返回回按钮消失、渐隐渐显Header区域 ####

  + 创建git分支：【detail-header】
  + pages/city/detail/components创建Header.vue
  + Detail.vue中：引入、注册、<detail-header></detail-header>
  + 页面需要足够长这样才可以滚动，∴Detail.vue中：写一个div帮助我们撑开页面的高度
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image316.gif)

+ Header.vue中：

  ```
  <template>
    <div>
      <router-link class="header-abs" 
                    to = "/" 
                    tag = div
                    v-show = "showAbs"
      >
         <span class="iconfont header-abs-back">&#xe624;</span>
         <!-- 点击区块，回到首页，router-link来实现。将div改成router-link -->
         <!-- to回到根路径"/"，希望他会自动回到首页。如果写“.",他却后退到了detail页面，空白 -->
      </router-link>
      <!-- 绑定style, 实现渐隐渐现的效果 -->
      <div class="header-fixed" v-show = "!showAbs" :style = "opacityStyle">
        <!-- 复制city页面的header进行修改 -->
        <!-- 这时候页面详情会一直显示在顶部，这个箭头会覆盖上面的箭头 -->
        <router-link to = "/">
          <div class="iconfont header-fixed-back">&#xe624;</div>
        </router-link>
        景点详情
      </div>
     </div>  
  </template>
  
  <script>
    export default {
      name: "DetailHeader",
      data() {
        return {
          showAbs: true,
          // 这个变量定义了是否显示header-abs。而header-fixed取反，刚进页面他是不显示的，
          // 只有当我滚动页面的时候，header-ads消失，他header-fixed才显示。所以监听scroll事件
          opacityStyle: {
          	opacity: 0
          }
          // 默认等于0，当用户在60--140之间滚动的时候，有一个渐隐渐现的效果.给判断条件添加140
        }
      },
      methods:{
        handleScroll(){
          const top = document.documentElement.scrollTop;
  //v-show实现刚进页面的时候显示返回按钮，Header区域景点详情不显示。什么时候显示Header区域景点详情呢？  往下滑到一定距离返回按钮隐藏、显示Header区域景点详情：通过对window的scroll事件进行监听
          if (top > 60) {
            this.showAbs =  false
            // 此时不仅显示顶部，还要加动画
            let opacity = top / 140  //这里要改用let来定义
            opacity = opacity>1 ? 1: opacity
            this.opacityStyle = {
              // 对opacityStyle对象添加属性，键和值都相等
              opacity: opacity
            }
            // 此时渐隐渐现的下过已经有了，但一旦超过140，就会顶部不显示了,去掉&& top < 140
            // 对opacity进行判断:opacity?1: opacity,,这样就没有问题了
          } else {
            this.showAbs =  true
          }
        }
      },
      activated(){
        // 在这个钩子里，用了keep-alive，所以当页面展示的时候他就会执行handleScroll方法
        window.addEventListener('scroll', this.handleScroll)
        // 这里addEventListener会带来问题：这是对window全局事件的监听，
        // 这个事件不是对组件的绑定，而是绑定到了window的全局对象上面了
        // Home组件也会收到影响，解决：deactived
      },
      deactivated() {
        // 所以我们要在离开组件的时候，移除对这一事件的监听
        window.removeEventListener('scroll', this.handleScroll)
      }
    }
  </script>
  
  <style lang = stylus scoped>
    @import "~styles/varibles.styl"
    .header-abs
      position: absolute
      left: .2rem
      top: .2rem
      width: .8rem
      height: .8rem
      line-height: .8rem
      border-radius: .4rem
      background rgba(0, 0, 0, .8)
      text-align: center
      .header-abs-back
        color: #fff
        font-size: .4rem
    .header-fixed
      position fixed
      top 0
      left 0
      right 0
      height $headerHeight
      line-height $headerHeight
      text-align center
      color #fff
      background $bgColor
      font-size .32rem
      z-index 2 
      /* 在详情页往下滑的时候，list前面的图标会浮出来，显示与顶部一起显示，z-index提高权重 */
      .header-fixed-back
        position absolute
        top 0
        left 0
        width .64rem
        text-align center
        font-size .4rem
        color #fff
  </style>
  ```

+ 'header animation'代码提交到git

### 9-4  Vue项目详情页-对全局事件的解绑 ###

很多初学者因为没有对全局事件进行解绑，造成代码出现大量的bug。

+ 如果在某个组件的标签上绑定这个事件(@click…)不会带来任何问题，因为这个事件绑定在组件的某个元素上所以只作用于这个组件的内部，不会影响外部的组件。
+ 可是如果在这个组件上写的是window全局事件的绑定，那就有问题了。 因为事件并不是绑定在组件中，而是绑定在了全局的window对象上了，所以不仅对这个组件有效果，而且对其他的组件也产生了影响。

解决：

+ 当对组件用了keep-alive，组件会多出activated生命周期函数，在每次页面展示时会执行。其实还提供一个生命周期函数deactivated，在页面即将被隐藏或者页面将被替换成新的页面时会被执行。

  ```
  页面展示的时候绑定scroll事件，而页面被隐藏时对scroll全局事件进行解绑
  activated () {    
  	window.addEventListener('scroll', this.handleScroll)   
  }
  deactivated () {    
  	window.removeEventListener('scroll', this.handleScroll)   
  }
  ```

+ 代码提交到git之前的分支【detail-header】
  查看分支：git branch
  ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image336.gif)

  + 当前处于master主分支：

    ```
    git add .，git commit -m 'fix problem'，git push，
    （让之前的detai-header分支和master分支作合并：）
    git checkout detail-header，git merge master，git push
    ```

  + 或者

    ```
    git checkout detail-header，git add .，git commit -m 'fix problem'，git push，
    git checkout master，git merge detail-header，git push
    ```

### 9-5  Vue项目详情页-使用递归组件实现详情页列表 ###

+ 新建git分支：【detail-list】
  pages/detail/components/创建List.vue
  Detail.vue引入这个组件DetailList、注册、使用

+ 在List.vue做递归组件

  ```
  <template>
    <div>
      <div v-for = "(item , index) in list" :key = index
          class="item">
          <div class="item-title">
            <span class="item-title-icon"></span>
            {{item.title}}
          </div>
          <!-- 在组件的上一部分，循环了list数据的以及内容，递归组件怎么使用呢 -->
          <!-- 他做了一个判断，如果item有children这个数据，说明他是一个多级菜单 -->
          <div v-if = "item.children" class="item-children">
            <!-- 在这里 :我们为一个组件起名字，他最大的用处就是在这里做递归组件的时候使用-->
            <!-- 此时把children当做list，再传给自己 -->
            <detail-list :list = "item.children">
            </detail-list>
          </div>
      </div>
    </div>
  </template>
  // class="item-children"把样式调整至分级的形式显示在页面--给个padding左右（而不是让二级列表和一级标题一样对齐显示）
  ```

+ 作业：剩下部分的布局和逻辑实现（用户评论+列表样式+评论的页面）

+ 'use recursive component'代码提交到git

### 9-6  Vue项目详情页-动态获取详情页面数据（使用Ajax获取动态数据） ###

+ 新建git分支：【detail-ajax】

+ 获取Ajax数据：

  ```
  Detail.vue中：     
  //借助生命周期钩子mounted 发ajax请求，  
  methods:里定义getDetailInfo方法，  引入axios，      Ajax数据获取完毕就可以输出结果了then(this.handleGetDataSucc)        
  if (res.ret && res.data) {     
  const data = res.data        console.log(data)      }可以输出数据        
  接下来把写死的数据换掉：  定义     sightName: '',     bannerImg: '',     gallaryImgs: [],     list: []  等于获取到的数据      this.sightName = data.sightName      this.bannerImg = data.bannerImg      this.gallaryImgs = data.gallaryImgs      this.list = data.categoryList                                                          |
  ```

  ```
  Detail.vue中： 
  data () {    
  	return { 
  		sightName: '',     
  		bannerImg: '',    
          gallaryImgs: [],     
          list: []    }   
         },   
  methods: {    
    getDetailInfo () {
    // 每一次请求希望把id带给后端，这个id是动态路由的参数，获得动态路由的参数：router/index里有path: '/detail/:id'，router定义了动态路由会把对应的id存在id这个变量里，∴可以这样写：axios.get('/api/detail.json' + this.$route.params.id)，但是这样拼接参数麻烦，可以写一个对象。
      	axios.get('/api/detail.json', {
          params: {
          id: this.$route.params.id
          } 
        }).then(this.handleGetDataSucc) },    
    handleGetDataSucc (res) {     
    	res = res.data     
    	if (res.ret && res.data) {      
    	   const data = res.data      
    	   this.sightName = data.sightName      
    	   this.bannerImg = data.bannerImg      
    	   this.gallaryImgs = data.gallaryImgs      
    	   this.list = data.categoryList     
    	}    
   } 
  },   
  mounted () {    this.getDetailInfo()   }  } 
  ```

  + 数据传子组件，替换

+ #### 问题：第一次进详情页会拿到0001的数据，第二次进入0002详情页并没有重新获取0002的数据，还是0001的数据 ####

  + 原因：和之前首页原理一样）因为detail页面通过keep-alive作了缓存，mounted只会执行一次

  + 解决：①如果想每次重新进页面都发一个ajax请求就需要使用activated生命周期钩子。

    ②exclude：Detail不被缓存，每一次进入详情页mounted钩子都会被重新执行，也就是重新获取数据
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image350.gif)

+ #### 问题：首页被拖到下面，再进入详情页，详情页也是被拖到下面而不是从顶部开始 ####

  + 解决：Vue Router官网>-进阶>-滚动行为
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image356.gif)
  + 复制到路由部分
    ![clipboard.png](file:///C:/Users/小虎牙/AppData/Local/Temp/msohtmlclip1/01/clip_image358.gif)

+ 思考：每个组件里面的name的用途：

  1. 递归组件
  2. 想对某个页面取消缓存时
  3. Vue开发调试工具Devtools，组件叫什么名字取决于name给的是什么名字

+ 'ajax'代码提交到git

### 10.1 接口联调 ###

* 在之前的static文文件夹下有一个mock文件夹，里面有json文件。当代码联调的时候，他们就没用了。而是切换为后端真实提供给我们的数据。http://localhost:80/api/index.json可以查看数据，不再请求本地mock文件夹的数据，删除之后，代码会有问题404。怎么做？
  config找到index.js。proxytable的代码意思开发环境下，如果你访问的是api路径，会将你对这个路径的请求转发到localhost8080端口上面。这个端口是前端服务器的端口，现在要更换后台服务器端口。这个端口还在本地，只是更改了地址。

* 实际中后端服务器并不在本地，这时候代理就不能写在localhost地址了，而是内网的ip地址。或者外网的一个域名。这样前端的api请求转发后后端服务器。如果项目使用的是vue这种，你就不需要再使用fiddler和charles这种抓包工具了。只需要使用proxytable这个配置项，就服务器的请求地址写在这里。

### 10.2 真机测试 ###

在windows系统中重新打开一个终端输入： ipconfig

![image-20210102171115248](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210102171115248.png)

 iPv4就是内网ip地址，复制地址，在浏览器输入这个地址。这个地址的8080端口就是localhost80端口。但是他拒绝了我们的连接请求，为了确认，将8080换成80。前端项目是通过webpack-dev-server启动的，他默认不支持通过ip的方式进行页面的访问，需要将默认配置package.json向进行修改：
我们每次运行npm run dev 本质运行：

```
"dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
```

修改为：

```
"dev": "webpack-dev-server --host 0.0.0.0 --inline --progress --config 	            build/webpack.dev.conf.js",
```

重启服务器

再通过ip地址进行访问就可以了

* 让手机直接通过内网ip地址尽心访问：

### 10  课程总结与后续学习 ###

##### 学习方向： #####

+ Vue官方文档：
  大部分内容都涉及到了，还有比如插件、自定义指令等多多查阅、提升边缘知识点能力。
+ 打开生态系统的vue-router插件，还有其他内容：命名路由、重定向、别名、守卫
+ Vuex：熟悉运用核心概念(State,Getter,Mutation,Action,Module)后，可以看一下在大型项目中创建比较复杂的Vuex数据架构时，项目结构怎么设计，或者如何使用Vuex相关的插件。
+ Vuex觉得没有太大的问题后：Vue服务器端渲染。搞明白意味着基本上对Node.js、Vue、前后端路由、前后端渲染有了极深的理解，前端的基础会得到很大的提升。如果时工作不满一年对前后端分得不是很清楚，这一部分内容可以延迟学习。

##### 插件研究： #####

+ 生态系统Vue资源：研究好用的插件的源码以及使用

##### 全面了解Vue后：研究Vue的源码 #####
