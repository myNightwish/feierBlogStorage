---
title: '项目3：购物街项目:学习笔记'
date: 2021-12-13 00:17:05
tags: Vue
categories: 项目总结
cover: https://images.unsplash.com/photo-1636980015567-01c079ac7304?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=435&q=80
copyright_author: 飞儿 
copyright_url: https://www.nesxc.com/post/hexocc.html 
license: CC BY-NC-SA 4.0
license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/
---
* 项目时间： 2020年11月-12月大概
* 项目背景： 给师姐做的（首页功能+购物车）
* 项目记录篇，比较啰嗦

## 项目首页Home笔记 ##

###  项目相关配置：项目的目录结构划分（主要是Src） ###

+ 去掉public里面的index.hml 的 favicon图标，去掉初始化的hellworld.vue

+ assets
  + img
    + cart
    + common
    + detail
    + home
    + profile
    + tabbar
  + css
    + normalize.css
    + base.css
+ components
  + common （这里放不仅仅当前项目可以用的，完全抽离的，还可以在将来的组件中应用）
    + tabbar 文件夹: TabBar.vue    TabBarItem.vue
    + navbar文件夹: NavBar.vue
    + scroll文件夹:    Scroll.vue
    + swiper文件夹 ：  index.js    Swiper.vue    SwiperItem.vue
    + toast文件夹 :        index.js    Toast.vue
  + content（和业务相关的公共组件，只针对当前项目）
    + maintabbar 文件夹:  MainTabBar.vue  （该组件实现了对底部4个模块的封装）
    + backTop文件夹:   BackTop.vue
  + goods文件夹：    GoodsList.vue    GoodsListItem.vue  
    + tabcontrol文件夹：  TabControl.vue  

+ views (我不希望把所有的组件全写在一起。整个页面业务相关的组件都放在这里)
  + home文件夹： Home.vue   和  childComps文件夹
    childComps：

    + FeatureView.vue

    + homeswiper.vue
    + RecommendView.vue

  + cart文件夹:  Cart.vue 和   childComps文件夹
    childComps文件夹:

    + CartBottomBar
    + CartList
    + CartListItem
    + CheckButton

  + detail文件夹： Detail组件  +   childComps文件夹
    childComps文件夹：
    + DetailImageInfo
    + DetailBaseInfo
    + DetailBottomBar
    + DetailCommentInfo
    + DetailGoodsInfo
    + DetailNavBar
    + DetailParamInfo
    + DetailShopInfo
    + DeatailSwiper

  + category文件夹  (无)
  + profile文件夹    （无）

+ router

  + index.js   （这里存放的是路由配置信息）
+ store

  + index.js 
  + mutation-type.js
  + actions.js
  + mutation.js
  + getters.js
+ network   (网络请求的封装)
  + request.js
  + home.js    这里封装了对首页数据的请求
  + detail.js
+ common
  + const.js   （抽出的常量）
  + util.js   （公共的方法或函数）
  + mixin.js    (混入)

#### 3.normalize.css和base.css ####

+ 去github上面下载normalize.css
+ 放入相应的文件夹中，在base.css中引入它
+ 将base.css在app.vue中使用

#### 4.vue.config.js文件和.editorconfig ####

+ 目的是为了配置路径别名的问题  cli2中，自动生成的base.config里面可以尽心更改。但cli3中是没有的，我们在项目下新建 vue.config.js文件。

```
  module.exports = {
    configureWebpack: {
      resolve: {
        alias: {
          'assets': '@/assets',
          'common': '@/common',
          'components': '@/components',
          'network': '@/network',
          'views': '@/views'
        }
      }
    }
  }
```

+ cli2中，自动生成的.editorconfig里面可以尽行更改。这里主要对整个项目的代码风格的统一
  而cli3中没有的，我们可以把之前的拿过来。比如一个公司的不同项目代码风格基本是一致的

#### 5.配置之前写好的MainBar组件 ####

+ 设置common里的文件tabbar 文件夹和maintabbar文件夹。并更改maintabbar里面的图片src
+ 因为这是我们从上一个项目里拿出来的，所以路径是要注意匹配的，方式参考vue.config.js
+ 将MainBar组件导入到App.vue里面

#### 6.项目模块的划分与路由配置信息 ####

+ 在views文件夹下创建4个子文件夹，每个文件夹下的组件只与你当前的页面相关

+ router文件夹下的index.js里。。在main.js里面导入+注册

  ```
  import Vue from 'vue'
  import VueRouter from 'vue-router'
  Vue.use(VueRouter)
  
  //路由的懒加载
  const Home = () => import('views/home/Home')
  const Profile = () => import('views/profile/Profile')
  const Cart = () => import('views/cart/Cart')
  const Category = () => import('views/category/Category')
  
  const routes = [
    {
      path: '',
      redirect: '/home'
    },
    {
      path: '/home',
      component: Home
    },
    {
      path: '/profile',
      component: Profile
    },
    {
      path: '/cart',
      component: Cart
    },
    {
      path: '/category',
      component: Category
    }]
  const router = new VueRouter({
    routes,
    mode: 'history',
  })
  export default router
  ```

+ 我在这里遇到了问题：		
  在点击首页之后，相应的页面没有显示？

  + 因为我在App.vue里没有加router-view，导致每个按钮点击后相关的组件全显示不出来

购物车页面又显示不出来????

+ 模板里的每个标签绑定了一个to属性。它告诉子组件，我现在在这个路径，你去router的配置里面，找跟我路径匹配的路由对象，并把它在我的页面展示出来。

  + to属性上的跟每个路由对象里的path是必须一致的。原来的/shopcart  而路由里面/cart。。他根本就没有建立联系，所以也不会显示内容

  第三个疑惑问题：为什么Home组件并没有在APP中进行引入，却可以在页面中显示呢？

  + 这其实跟上面的原理都是一致的。因为页面展示出来的内容是通过路由配置信息找到的组件，再由router-view将这部分组件的内容进行展示。
    路由相关知识总结：https://www.cnblogs.com/samweb/p/6610733.html

### 1. 导航栏开发 ###

+ 显示效果
  ![image-20201202204147460](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201202204147460.png)

+ NavBar组件：

  ```vue
  <template>
    <div class="nav-bar">
      <!-- 1.注意这里不要对slot进行直接布局，而是用div给他包起来，给div布局 -->
      <!-- 2.插槽必须要有名字，这样我们插得时候才能对应起来，指定替换的是哪一个 -->
      <div class="left"><slot name="left"></slot></div>
      <div class="center"><slot name="center"></slot></div>
      <div class="right"><slot name="right"></slot></div>
    </div>
  </template>
  <script>
  export default {
    name: 'NavBar'
  }
  </script>
  <style scoped>
    /* 为插槽设置样式，使用flex布局 */
    .nav-bar {
      display: flex;
      /* 导航栏的高度一般是44.如果是有导航栏高度是64 */
      height: 44px;
      line-height: 44px;
      box-shadow: 0 1px 1px rgba(100, 100, 100, 1);
    }
    /* 一般左边插槽时固定的，右边也是，中间占用剩余的 */
    .left,
    .right {
      width: 60px;
    }
    .center {
      flex: 1;
      text-align: center;
    }
  </style>
  ```

+ ```
      <nav-bar class="home-nav">
        <div slot = "center">购物街</div>
      </nav-bar>
      导入+注册
      <style scoped>
        .home-nav {
          background-color: var(--color-tint);
          color: #fff;
        }
  </style>
  ```

+ 分析： 

  + 容易忘记在Home里面导入，最易犯错的是没有在components里面注册就使用

  + 首先这个组件有左、中、右三部分。这三个位置设置了插槽，通过Home组件里v-slot，和子组件里的插槽name，我们可以随意指定哪一个位置的内容是什么。如果我们不想用哪个插槽，只要Home组件里没有与它对应的标签即可
  + 插槽里面的内容如何实现定制呢？
    在Home组件里，我们通过导入和注册的子组件里，把想插入的元素用div之类的包裹即可。注意slot名字要与子组件名字对应

### 2.网络数据的请求封装 ###

+ 网络请求文件是在network下面进行的。我们不要在每个子组件下都进行网络请求。一来，容易服务器拥挤

  二来，当我有一天服务器借口进行改变时，所有的子组件都要进行更高。这对于项目开发来说是非常灾难的。所以不要这样做，不易维护

+ 首先是request.js文件

  ```vue
  //首先要安装axios：npm install axios@0.18.0 --save    再导入axios
  import axios from 'axios'
  export function request(config) {
    // 1.创建axios的实例
    const instance = axios.create({
      //换掉端口地址
      baseURL: 'http://152.136.185.210:8000/api/w6',
      timeout: 5000
    })
    // 2.axios的拦截器
    // 2.1.请求拦截的作用
    instance.interceptors.request.use(config => {
      return config
    }, err => {})
    // 2.2.响应拦截
    instance.interceptors.response.use(res => {
      return res.data
    }, err => {})
    // 3.发送真正的网络请求
    return instance(config)
  }
  ```

+ home.js文件

  + 为什么还要进行一个封装？难道request不够吗？
    + 这种封装的意义在于，home组件面向home.js开发。home组件里所有需要获取的内容，你只需要调用这个函数，而不需要关心数据请求中url之类的配置.因为调用的封装函数已经设置过这些
    + 当有一天借口发生了变化，我们只需要在这里进行修改，对应的home组件的数据自动发生相应的更新。如果我们去home组件里进行网络请求，则会造成，所有url的地方都需要修改。当项目组件很多的时候，这是很恐怖的

  ```vue
  //对首页数据的封装请求写在这里。而不是在request中完成对所有数据的封装
  import axios from 'axios'
  import { request } from './request'
  //封装的是一个函数，他的名字叫getHomeMultidata
  export function getHomeMultidata () {
    //这里返回的是一个promise对象，在那边进行.then拿到结果
    return request({
      url: '/home/multidata'
    })
  }
  ```

+ Home组件：拿到了待会要用的数据，并进行了初次的保存

  ```vue
  //因为那边没有default导出，所以不能去掉大括号！！！！
  import {getHomeMultidata} from 'network/home'
  data() {
      return {
        result: null,
        banners: [],
        recommends: [],
        keywords: [],
        dKeywords: []
      }
    },
    //当首页组件创建完成之后，赶紧进行网络请求，待会要进行展示
    created () {
      //1.请求多个数据    getHomeMultidata()调用函数，进行数据请求   .then()拿到请求后的结果
      getHomeMultidata().then( res => {
        this.result = res;
      //这个函数调用的时候会有函数执行栈，在调用结束后执行栈里面的数据会被全部销毁掉，所以我们要对他进行一个保存
      
      //垃圾回收机制：时间---等到没有引用指向他的时候进行垃圾回收。res指向的是一个对象，当执行完之后，
      //会销毁掉变量res。此时rs指向的那个数据里面就没有被引用了，孤零零，最后垃圾回收机制会将它也销毁掉，
      //result对res赋值，其实是内存地址。而此时的数据对象有了reult来引用他，所以这个数据不会被销毁掉
      //其实这跟堆栈相关，以及执行上下文栈
      //可以通过devtool插件里面的vue的HOME结构下看到result里面已经保存了数据
      
      //改进。从数据对象里面取出来每一项
      this.banners = res.data.banner.list
      this.recommends = res.data.recommend.list
      //注意这里请求过来的数据里就是复数
      this.keywords = res.data.keywords
      this.dKeywords = res.data.dKeywords
      })
    }
  }
  ```

+ 补充两个知识点：

  + ##### 模块的导入导出方式： #####

    + commandJs方式（导入导出对象）：modules.exports = {}    var aa = require('路径文件')

    + ES6方式：

      + 直接导入变量：import  {a}  from '~~' ，必须有花括号

      + 统一全部导入：import  {a,b,c}  from '~~' (函数，类，变量都可以)
      + 导出函数/类：export function aa(){}       export class bb{}
      + 默认导出：export default {}   只能有一个默认导出，在对这种进行导入的时候可以随意起名字
        例如：import  AA  from  ‘路径文件’ 

  + ##### **Vue的生命周期** #####

    Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。

    **实例生命周期钩子**

    每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。对应的8个生命周期钩子函数：

    * **beforeCreate、created**、
    * **beforeMount、mounted**、
    * **beforeUpdate、updated**、
    * **beforeDestroy、destroyed**

    **Vue的生命周期图示（官方中文文档）**
    <img src="https://img-blog.csdnimg.cn/20200418104137666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NDX1RvZ2V0aGVy,size_16,color_FFFFFF,t_70" alt="官方图示" style="zoom:50%;" />
    <img src="https://img-blog.csdnimg.cn/20200418101911580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NDX1RvZ2V0aGVy,size_16,color_FFFFFF,t_70" alt="图片转自coderwhy老师" style="zoom: 50%;" />

    **Vue的生命周期过程详解（主要以钩子函数为主线）**

    **1、beforeCreate：**
    实例组件通过new Vue() 创建出来之后会初始化事件和生命周期，然后就会执行 beforeCreate 钩子函数，**数据和 dom 都未初始化**（取不到），一般不做任何操作。

    **2、created：**
    **挂载数据，绑定事件已完成**，然后执行created函数，这个时候已经可以操作数据, 而且不会触发 updated 函数，一般在这里做初始数据的获取（相比在 beforeMount 获取数据页面渲染速度较快）。

    **3、beforeMount：**
    执行这个函数前，**虚拟dom 创建完成，真实 dom未完成挂载**。这里更改数据不会触发 updated ，在这里也可以做初始数据的获取。

    **4、mounted：**
    执行 mounted 钩子函数前，**数据、真实dom都已经处理好了**,事件也挂载好了，一般在这里初始化一些操作真实 dom 的方法。

    **5、beforeUpdate：**
    当组件或实例的数据更改，会立即执行beforeUpdate，然后vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染。可以监听到 **data 变化，但view层的数据还没有变化**。一般不做任何操作。

    **6、updated：**
    view层的数据重新渲染完成后，执行updated，数据已经更改完成，dom也重新render完成，可以操作更新后的虚拟dom

    **7、beforeDestroy：**
    当经过某种途径调用$destroy方法后，立即执行beforeDestroy，一般在这里做一些善后工作，例如清除计时器、数据和事件的监听等。

    **8、destroyed：**
    组件的数据绑定、事件监听清除后只剩下dom空壳，这个时候，执行 destroyed 彻底销毁实例，如果在 beforeDestroy 没有做善后工作，在这里做善后工作也可以。

    **注**：掌握各个钩子函数执行时的环境，并在项目开发中正确使用显得尤为重要，能避免一些基础的bug。

### 3.首页轮播图 ###

![image-20201202204213590](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201202204213590.png)

+ Home组件

  + 轮播图是放在首页导航栏的下面的。但是这一部分我们不要直接在Home组件里写。Home组件下面还有要显示的内容，如果我们都写在这里最后，Home会越来越多。所以只要是个独立的一块，我们都要进行封装

  ```
  <home-swiper :banners = "banners"></home-swiper>
  import HomeSwiper from './homeswiper/HomeSwiper'
  ```

+ 在homeswiper下的HomeSwiper组件

  ```vue
  <!-- home里面放主要的逻辑，组件里面怎么封装的，我并不关心。所以不要把swiper直接写在这里，抽离到home的新文件下，放他的子组件 -->
  <template>
    <swiper>
      <!-- 轮播的每一项用swiper-item  SwiperItem的组件里面预留了插槽，所以我们可以往里面插入我想插入的东西-->
      <!-- 这里不要创建4个项，而是循环起来 从banners里面取出数据，取代插槽里面的内容-->
      <swiper-item v-for="item in banners" :key="item.index">
        <!-- 因为图片是可以点击的，所以这里我们要给他包装一个标签a -->
        <!-- 链接中href属性是获取数据banners里面有一个link -->
        <a :href="item.link">
          <!-- item.image是不对的，要动态绑定，所以要绑定到image里面的src上面-->
          <img :src="item.image" alt="">
        </a>
      </swiper-item>
    </swiper>
  </template>
  
  <script>
  //因为index.js文件对导出组件进行同一导出，所以这里我们不需要再一个一个地导入了
   //因为那边没有default导出，所以不能去掉大括号！！！！
  import {Swiper, SwiperItem} from 'components/common/swiper'
      //等价于：// import Swiper from 'components/common/swiper/Swiper'
  // import SwiperItem from 'components/common/swiper/SwiperItem'
    export default {
      name: "HomeSwiper",
      props: {
        banners: {
          type: Array,
          default() {
            return []
          }
        }
      },
      components: {
        Swiper,
        SwiperItem
      }
    }
  </script>
  ```

+ Swiper组件

  ```
  <template>
      <div id="hy-swiper">
        <div class="swiper" @touchstart="touchStart" @touchmove="touchMove" @touchend="touchEnd">
          <slot></slot>
        </div>
        <slot name="indicator">
        </slot>
        <div class="indicator">
          <slot name="indicator" v-if="showIndicator && slideCount>1">
            <div v-for="(item, index) in slideCount" class="indi-item" :class="{active: index === currentIndex-1}" :key="index.id"></div>
          </slot>
        </div>
      </div>
  </template>
  
  <script>
  	export default {
  		name: "Swiper",
      props: {
        interval: {
  		    type: Number,
          default: 3000
        },
        animDuration: {
  		    type: Number,
          default: 300
        },
        moveRatio: {
          type: Number,
          default: 0.25
        },
        showIndicator: {
          type: Boolean,
          default: true
        }
      },
      data: function () {
  		  return {
          slideCount: 0, // 元素个数
          totalWidth: 0, // swiper的宽度
          swiperStyle: {}, // swiper样式
          currentIndex: 1, // 当前的index
          scrolling: false, // 是否正在滚动
        }
      },
      mounted: function () {
        // 1.操作DOM, 在前后添加Slide
        setTimeout(() => {
          this.handleDom();
  
          // 2.开启定时器
          this.startTimer();
        }, 100)
      },
      methods: {
  		  /*** 定时器操作*/
        startTimer: function () {
  		    this.playTimer = window.setInterval(() => {
  		      this.currentIndex++;
  		      this.scrollContent(-this.currentIndex * this.totalWidth);
          }, this.interval)
        },
        stopTimer: function () {
          window.clearInterval(this.playTimer);
        },
        /*** 滚动到正确的位置*/
        scrollContent: function (currentPosition) {
          // 0.设置正在滚动
          this.scrolling = true;// 1.开始滚动动画
          this.swiperStyle.transition ='transform '+ this.animDuration + 'ms';
          this.setTransform(currentPosition);
  
          // 2.判断滚动到的位置
          this.checkPosition();
  
          // 4.滚动完成
          this.scrolling = false
        },
        //校验正确的位置
        checkPosition: function () {
          window.setTimeout(() => {
            // 1.校验正确的位置
            this.swiperStyle.transition = '0ms';
            if (this.currentIndex >= this.slideCount + 1) {
              this.currentIndex = 1;
              this.setTransform(-this.currentIndex * this.totalWidth);
            } else if (this.currentIndex <= 0) {
              this.currentIndex = this.slideCount;
              this.setTransform(-this.currentIndex * this.totalWidth);
            }
            // 2.结束移动后的回调
            this.$emit('transitionEnd', this.currentIndex-1);
          }, this.animDuration)
        },
        //设置滚动的位置
        
        setTransform: function (position) {
          this.swiperStyle.transform = `translate3d(${position}px, 0, 0)`;
          this.swiperStyle['-webkit-transform'] = `translate3d(${position}px), 0, 0`;
          this.swiperStyle['-ms-transform'] = `translate3d(${position}px), 0, 0`;
        },
         //操作DOM, 在DOM前后添加Slide
         
  		  handleDom: function () {
          // 1.获取要操作的元素
          let swiperEl = document.querySelector('.swiper');
          let slidesEls = swiperEl.getElementsByClassName('slide');
          // 2.保存个数
          this.slideCount = slidesEls.length;
          // 3.如果大于1个, 那么在前后分别添加一个slide
          if (this.slideCount > 1) {
            let cloneFirst = slidesEls[0].cloneNode(true);
            let cloneLast = slidesEls[this.slideCount - 1].cloneNode(true);
            swiperEl.insertBefore(cloneLast, slidesEls[0]);
            swiperEl.appendChild(cloneFirst);
            this.totalWidth = swiperEl.offsetWidth;
            this.swiperStyle = swiperEl.style;
          }
          // 4.让swiper元素, 显示第一个(目前是显示前面添加的最后一个元素)
          this.setTransform(-this.totalWidth);
        },
        /**
         * 拖动事件的处理
         */
        touchStart: function (e) {
          // 1.如果正在滚动, 不可以拖动
          if (this.scrolling) return;
          // 2.停止定时器
          this.stopTimer();
          // 3.保存开始滚动的位置
          this.startX = e.touches[0].pageX;
        },
        touchMove: function (e) {
          // 1.计算出用户拖动的距离
          this.currentX = e.touches[0].pageX;
          this.distance = this.currentX - this.startX;
          let currentPosition = -this.currentIndex * this.totalWidth;
          let moveDistance = this.distance + currentPosition;
          // 2.设置当前的位置
          this.setTransform(moveDistance);
        },
        touchEnd: function (e) {
          // 1.获取移动的距离
          let currentMove = Math.abs(this.distance);
          // 2.判断最终的距离
          if (this.distance === 0) {
            return
          } else if (this.distance > 0 && currentMove > this.totalWidth * this.moveRatio) { // 右边移动超过0.5
            this.currentIndex--
          } else if (this.distance < 0 && currentMove > this.totalWidth * this.moveRatio) { // 向左移动超过0.5
            this.currentIndex++
          }
          // 3.移动到正确的位置
          this.scrollContent(-this.currentIndex * this.totalWidth);
          // 4.移动完成后重新开启定时器
          this.startTimer();
        },
        /**
         * 控制上一个, 下一个
         */
        previous: function () {
          this.changeItem(-1);
        },
        next: function () {
          this.changeItem(1);
        },
        changeItem: function (num) {
          // 1.移除定时器
          this.stopTimer();
          // 2.修改index和位置
          this.currentIndex += num;
          this.scrollContent(-this.currentIndex * this.totalWidth);
          // 3.添加定时器
          this.startTimer();
        }
      }
  	}
  </script>
  
  <style scoped>
    #hy-swiper {
      overflow: hidden;
      position: relative;
    }
    .swiper {
      display: flex;
    }
    .indicator {
      display: flex;
      justify-content: center;
      position: absolute;
      width: 100%;
      bottom: 8px;
    }
    .indi-item {
      box-sizing: border-box;
      width: 8px;
      height: 8px;
      border-radius: 4px;
      background-color: #fff;
      line-height: 8px;
      text-align: center;
      font-size: 12px;
      margin: 0 5px;
    }
    .indi-item.active {
      background-color: rgba(212,62,46,1.0);
    }
  </style>
  ```

+ SwiperItem组件

  ```
  <template>
    <div class="slide">
      <slot></slot>
    </div>
  </template>
  
  <script>
  	export default {
  		name: "Slide"
  	}
  </script>
  
  <style scoped>
    .slide {
      width: 100%;
      flex-shrink: 0;
    }
    .slide img {
      width: 100%;
    }
  </style>
  ```

+ 这块的难点与任务：

  + 那么点这两个组件时如何完成封装的，你会写出原生封装吗？

  + 学习一个插件：vue-awesome-swiper  踏实如何实现轮播效果的呢？？组件图的封装，github上进行了封装‘，这些库学习的时候不建议随便用UI库，而是自己封装，自己才能明白是怎么封装的。。。。。



### 4.首页推荐信息 ###

![image-20201202204250774](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201202204250774.png)

+ Home组件

  ```
  <home-recommend :recommends = "recommends"></home-recommend>
  导入+注册
  ```

+ HomeRecommend组件

  ```
  <template>
    <div class="home-recommend">
      <!-- 对轮播图里面的数据进行展示 -->
      <div v-for="item in recommends" 
          :key = "item.index"
          class="recommend-item"
          >
        <!-- 每个都是有标签的 ,数据中的link属性对应的就是每个图片点击后的超链接地址-->
        <a :href="item.link">
          <img :src="item.image" alt="" class="img">
          <!-- 每个小图片有文字 -->
          <div>{{item.title}}</div>
        </a>
      </div>
    </div>
  </template>
  
  <script>
    export default {
      name: "HomeRecommend",
      //数据在首页里面，所以我们要接收，不然哪儿来的数据。而且父组件也要把数据传过来
      //这两点总是爱忽略，遗漏
      props: {
        recommends: {
          type: Array,
          default() {
            return []
          }
        }
      }
    }
  </script>
  
  <style>
    .home-recommend {
      /* 水平布局，flex，因为盒子全部在一列排列 */
      display: flex;
      width: 100%;
      font-size: 12px;
      /* 居中显示 */
      text-align: center;
      /* 让他与上面和下面拉开一点距离*/
      padding: 10px 0 20px;
      border-bottom: 8px solid #eee;
    }
    .recommend-item {
      flex: 1;
    }
    .recommend-item .img {
    /* 此时图片太大了。对图片进行限制 */
    /* 与老师不同，我对这里的图片用的是百分比，不是定的px */
      width: 80%;
      height: 80%;
      /* 图片和文字距离拉开 */
      margin-bottom: 10px;
    }
  </style>
  ```

### 5. 本周流行 ###

+ 这块只有一个图片，虽然看起来像很多个小图标。但我们还是将它封装成一个组件Feature

  ![image-20201203175355996](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201203175355996.png)

+ FeatureView组件

  ```
  <template>
    <div class="feature">
      <a href="#">
        <img src="~assets/img/home/recommend_bg.jpg" alt="">
        //注意这里的src是有波浪线的
      </a>
    </div>
  </template>
  
  <script>
    export default {
      name: 'FeatureView'
    }
  </script>
  
  <style scoped>
  .feature img{
    width: 100%;
  }
  </style>
  ```

+ Home组件   导入+注册+使用该组件即可

### 6.控制栏 ###

+ 需求：点击这三个任一个，哪一个颜色改变，有下面的线，并展示相应的页面
  ![image-20201203180154105](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201203180154105.png)

  + 分析：这种需求似乎跟之前的TabBar组件很像，但是这里我们并没有采用那种封装思想

  + TabBar的封装思想是：每一项都是文字+图标的形式，他们的展示形式也是一样的。将每一项抽离成一个组件进行封装，而组件里我们预留了插槽。我们将来用的时候，可以在插槽的位置填入想要定制化的内容。可以改变每次插入的文字，甚至可以改变个数，这时候就需要预留插槽

  + 首先这个组件我是可以在第二页面进行复用的，他们都是一样的，只是文字不一样。如果这里我们也要这样做，带来的问题就是你用的时候组件里这样，他用的时候组件也这样。插槽的形式都是一样的，代码是重复的

    ```
    不推荐 <tab-bar><span>aa</span></tab-bar>
          <tab-bar><span>bb</span></tab-bar>
          <tab-bar><span>cc</span></tab-bar>
          <tab-bar><span>dd</span></tab-bar>
    ```

+ TabControl组件

  + 组件复用问题：

    当我切换流行，时尚，详情时，组件页面并没有发生改变：

    原因组件复用的问题。原来的图片。类似于之前的input复用问题。解决办法：绑定key

  ```
  <template>
    <div class="tab-control">
         <!-- 点击哪一个，下面添加样式。样式的动态绑定 -->
         <!-- 里面有几个span，是根据title有几项数据决定跟的 -->
       <div v-for="(item, index) in titles" 
            :key="(item, index)"
            class="tab-control-item"
            :class = "{active: index === currentIndex}"
            @click = "btnClick(index)">
        <!-- 添加点击事件，点击哪一个，为其添加acive的class类 -->
        <span>{{item}}</span>
        </div>
    </div>
  </template>
  
  <script>
    export default {
      name: "TabControl",
      props: {
        //传进来title,告诉别人我用的时候你只需要给我传文字就可以了。
        titles: {
          type: Array,
          default() {
            return []
          }
        }
      },
      data() {
        //return 返回的是一个对象，不是函数！！！
        return {
          currentIndex: 0
        }
      },
      methods: {
        btnClick(index) {
          this.currentIndex = index;
        }
      }
    }
  </script>
  
  <style scoped>
    .tab-control {
      display: flex;
      text-align: center;
      font-size: 16px;
    }
    .tab-control .tab-control-item {
      flex: 1;
      height: 40px;
      line-height: 40px;
    }
    .tab-control-item span {
      /* 撑开一下便捷，左边和下边都会有一些距离 */
      padding: 5px;
    }
    .active {
      color: #ff5777;
    }
    .active span {
      /* 不要整个部分全显示，而是现实span短横 */
      border-bottom: 3px solid var(--color-tint);
    }
  </style>
  ```

+ Home组件

  ```
  	导入+注册
      data里定义titles的内容： titles:['流行','新款','精选'],
      <tab-control :titles = "titles" class="tab-control"></tab-control>
      //这里为什么还有个class,跟下面的需求有关
  ```


+ 此时我们要实现一个需求：
  + 首页上面的导航栏，用户向下滚动的时候他不要跟着滚动，用定住最上面（固定定位），我这个组件也也同样固定在导航栏的下面（粘连定位）

```
  .home-nav {
    background-color: var(--color-tint);
    color: #fff;
    /* 首页上面的导航栏，向下滚动的时候他不要滚动。采用固定定位，一直在最上面 */
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 9;
  }
    #home {
    /* 如果这里没有44px,轮播图会跑到最上面，他的一部分就会被导航栏遮盖 */
   	padding-top: 44px;
  }
  .tab-control {
    /* 想实现的功能是：页面向下滑，滑到一定高度后，顶部固定 */
    /* 方法1：用定位做。方法2：后续用插件做 */
    position: sticky;
    // 距离顶部44px的时候，会变成fixed定位
    top: 44px;
    background-color: #fff;
  }
```

### 7.控制栏点击之后的数据请求 ###

+ 分析：

  我们对这部分封装在content里，与业务逻辑有关,不是完全独立，又可以应用在该项目其他页面的某些地方

  点击之后请求过来的数据是什么形式的呢?我们又如何保存？

  + 我们需要一个变量，这个变量不仅存储着流行 新款 精选 的数据  当用户点击对应的某一项时，就展示那一项的数据。所以我们会一次把数据都请求过来。这种思想其实跟tabbar一样一样的。但有一个问题：

    流行的数据有很多页。数据量很大。？？？怎么保存

  + 数据保存模型：

    + 拿到整体的数据goods,保存着三类数据，每一类数据对应着一个对象。

    + list对象里面存放的展示数据。page因为要展示的图片很多，他会显示我们当前浏览到第几页了

      流行页面已经浏览了第5页，此时我点击新款页面，他应该是第1页。page就是记录这个页

    + 当我点击流行按钮的时候，就要把pop对象里面的数据请求过来，点击新款时，把news里面的数据请求过来点击详情时，把sell里面的数据请求过来，展示他里面的数据。取数据是通过key实现的。

    + 如果用户产生了上拉加载更多的操作，我们还应该改page.还需要list展示已经展示了多少条数据

    ```
     goods: {
        'pop': {page： 1， list： []}，每个数据对象 默认page，还有key和value记录当前模型加载到		第几页的
    ‘news': {},
        'sell': {}
     }//这个数据模型会帮我们把请求的数据保存下来
    ```

  + 第二种保存数据的方法：Map数据结构，？？？学习一下？？



+ ##### 数据请求操作： #####

  同样我们要在network里面的home.js里完成请求

  ```
  export function getHomeGoods(type, page) {
    //这个函数跟上面不同，因为要针对不同的情况请求不同的数据，
    //所以我们要传入参数一个时type，每一类你还要告诉我对应的页码，我有了页码采取请求对应的数据
    return request ({
      url: '/home/data',
      params: {
        type,
        page
      }
    })
  }
  ```

  在Home组件里调用

  + Level1   跟之前轮播图数据一样，在created里面调用home.js里的数据请求函数

  ```
   //   getHomeGoods(type, 1).then(res => {
      //     console.log(res)
      //   })
  ```

  但并不推荐这样做。因为避免created里面每个函数调用后我们在里面做较多的保存工作，我们要对这部分进一步封装在methods里面。至于created里面是怎么保存的我不关心。我只关心你的数据请求，所以最好只写主要逻辑

  + 把这部分功能放在methods里封装成函数，在created里面调用

    ```
       // getHomeGoods(type, page) {
        //   getHomeGoods(type, 1).then(res => {
        //     console.log(res)
        //   })
        // }
    ```

  + 改进问题： 这样写page是死的，为了提升代码的复用性。当我浏览完第一个页面的第一页数据后，用户上拉加载更多，这时候要请求第二个数据了，但是我们将page固定位1，问题是我们还需要写新的函数来解决这个需求
    解决：通过传入的type，获取到page。page初始化为0，我们希望3个页面在开始的时候都是请求第一页

    ```
      created () {
        this.getHomeMultidata()
        //我们希望3个页面在开始的时候都是请求第一页
        this.getHomeGoods('pop')
        this.getHomeGoods('new')
        this.getHomeGoods('sell')
      //注意这两个地方的调用必须写this。如果不写this，其实还是在调用home.js里面的函数
      //而我们实际想要调用的是methods里面的.他里面对数据进行了保存
      },
    ```

    ```
    methods: {
       getHomeGoods(type) {
          const page = this.goods[type].page + 1
          getHomeGoods(type, page).then(res => {
            //获取到请求结果res，得到res.data我们要进行一个保存。存储数据的模型是goods
            //问题：如何将一个数组的所有数据保存在另一个数组里面？
            //第一种对第2个数据每一项进行遍历，然后每一项push塞进第一个数组
            //方法2： 使用push方法  num2.push(...num1)
            //相当于也是一种解析，会将数组中每个元素解析出来放入数组2
            //更深的理解：利用push函数，它可以传入可变参数，可以传入很多个
            this.goods[type].list.push(...res.data.list)
            //现在的pop类型多了一组数据，我们要将页码+1
            this.goods[type].list.page +=1
          })
        }
      },
    ```

    ```
    //data里面的数据初始化
          goods: {
            //现将数据设置好，然后去请求数据。将请求回来的数据在这里面放
            'pop': {page: 0, list: []},
            'new': {page: 0, list: []},
            'sell': {page: 0, list: []},
          },
    ```

### 8. 商品数据展示 ###

+ ##### 请求的数据保存后，如何显示在页面上呢？ 组件GoodsItem和GoodsList #####

  思路：Home组件将数据传给GoodsList，GoodsList进行遍历，然后将遍历出来的每一项传给他的GoodsListItem，它接收数据中，进行展示 -

  Home组件

  ```
  <goods-list :goods = "goods['pop'].list"></goods-list>
  导入+注册
  ```

  GoodsList组件：

  ```
  <template>
    <div class="goods-item">
      <goods-list-item v-for = 'item in goods' 
                      :key="item.index"
                      :goodsitem = "item">
      <!-- 将遍历出来的每一个对象，传到子组件中进行显示 -->
      </goods-list-item>
    <!-- 每个小组件就是遍历的每个对象 -->
    </div>
  </template>
  
  <script>
  import GoodsListItem from './GoodsListItem'
  export default {
      name: 'GoodsList',
      components: { GoodsListItem },
      //这个位置接受的就是穿过来的list，进行展示
      props: {
        goods: {
          type: Array,
          default() {
            return []
          }
        }
      }
    }
  </script>
  
  <style scoped>
    .goods-item {
      display: flex;
      /* 目的是不要让图片占满一整行，注意子元素这是必须给宽度，否则，它会全往一行塞 */
      /* 而且光给宽度还不行，flex-wrap会wrap进行换行，配合子元素的宽度，它会自动进行换行
      默认是nowrap，是不换行的*/
      flex-wrap: wrap;
      justify-content: space-around;
    }
  </style>
  ```

  GoodsListItem组件：

  ```vue
  <template>
    <div class="goods-item">
      <img :src = "goodsitem.show.img"/>
      <!-- 图片下方还有一个标题+价格+收藏collect favorite -->
      <div class="goods-info">
        <p>{{goodsitem.title}}</p>
        <span class="price">{{goodsitem.price}}</span>
        <span class="collect">{{goodsitem.cfav}}</span>
      </div>
    </div>
  </template>
  
  <script>
    export default {
      name: 'GoodsListItem',
      props: {
      goodsitem: {
          type: Object,
          default() {
            return {}
          }
        }
      }
    }
  </script>
  
  <style scoped>
    .goods-item {
      padding-bottom: 40px;
      position: relative;
      /* 父元素右flex这里要给宽度 */
      width: 46%;
  
    }
  
    .goods-item img {
      width: 100%;
      border-radius: 5px;
    }
  
    .goods-info {
      font-size: 12px;
      position: absolute;
      bottom: 5px;
      left: 0;
      right: 0;
      overflow: hidden;
      text-align: center;
    }
  
    .goods-info p {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-bottom: 3px;
    }
  
    .goods-info .price {
      color: var(--color-high-text);
      margin-right: 20px;
    }
  
    .goods-info .collect {
      position: relative;
    }
  
    .goods-info .collect::before {
      content: '';
      position: absolute;
      left: -15px;
      top: -1px;
      width: 14px;
      height: 14px;
      background: url("~assets/img/common/collect.svg") 0 0/14px 14px;
    }
  </style>
  ```

  + 遇到的问题1：如果子元素不给宽度的结果，全网一行塞
    ![image-20201203205335489](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201203205335489.png)

    为了不要让图片占满一整行，注意子元素必须给宽度，否则，它会全往一行塞 。而且光给宽度还不行，flex-wrap会wrap进行换行，配合子元素的宽度，它会自动进行换行
    默认是nowrap，是不换行的默认是nowrap，是不换行的*/flex-wrap: wrap;

  + 问题2：一行的图片并不是均等分的  ： justify-content: space-around;

    ​	<img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201203205855794.png" alt="image-20201203205855794" style="zoom:67%;" />

  + 问题3：下滑的过程中，流行，新款的导航栏会被覆盖掉，

    解决：去TabControl组件添加z-index：9

+ ##### Home组件中如何实现数据动态传给子组件？？ #####

  ```
      <goods-list :goods = "goods['pop'].list"></goods-list>
      这个传数据时，直接是写死的这样肯定是不行的。我们点击详情，新款时他就不能动态展示当前选择的类型里面的内容。
  ```

  实现的思路：在TabControl组件中的每一项被点击时，告诉Home组件当前被点击的是哪个index。Home组件根据index就知道了他应该切换为pop还是new还是sell里面的数据

  在TabControl的方法中修改：

  ![image-20201203230845680](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201203230845680.png)

  父组件监听这个自定义事件：

  ```
      <tab-control :titles = "titles" 
                    class="tab-control" 
                    @tabClick="tabClick"></tab-control>   
      //后续借助计算属性对这部分优化
      <goods-list :goods = "goods[currentType].list"></goods-list>
                    
      /*2.这是事件监听类的方法*/
     方法里： tabClick(index) {
        console.log(index)
        console.log('haha');
        
        switch (index) {
          case 0: this.currentType = 'pop'
          break
          case 1: this.currentType = 'new'
          break
          case 2: this.currentType = 'sell'
          break
        }
      },
      数据里： 初始化类型
        currentType: 'pop',
  ```

  + 犯错1： @tabClick = "tabClick(index)"父组件中这个监听事件应该绑定到TabControl里面，不是goodlist上面
  + 犯错2：这里@tabClick = "tabClick(index)"不要传参数，会导致index打印出是无效的，这是为什么呢？

  

  

  

  + 遇到的问题：Home.vue?76f2:158 Uncaught (in promise) TypeError: Cannot read property 'data' of undefined at eval Error: timeout of 5000ms exceeded
    at createError (createError.js?2d83:16)at XMLHttpRequest.handleTimeout (xhr.js?b50d:95)一直显示data没有定义，数据请求不过来
    解决：报错data没有定义,原因是我在request.js里面设置了5000ms，也就是超过5秒就超时，这时候还没有达到数据，我们用数据是有问题的。

    我尝试了修改timeout的数值，发现控制台没有再报错，同时请求的3条数据也显示出来。不再像之前那样部分显示，部分报错

  + 接上一个问题：另一个问题：为什么我只执行了一次打印，却会打印出三条请求数据的结果呢？

    因为我们在上面的生命周期created里面调用了3种

+ ##### Home中计算属性优化 #####

  ```
  <goods-list :goods = "goods[currentType].list"></goods-list>
  
  computed: {
    showGoods() {
     return this.goods[this.currentType].list
    }
  ```

  + 犯错：注意return this.goods[this.currentType].list这里面是要加this的，在之前写在组件里不同加this，现在是写在下面，不加this，根本不认识它。没加会报错的！！！这个地方极容易犯错

### 9.关于Better-scroll ###

问题： 当前项目部署到服务器，只有用手机端请求网页，这个网页样式是没有问题的。我想往上滚，它是不会像PC浏览器里面自带的原生滚动一样  内容超过当前窗口的页面，可以自动滚动  。手机端会非常卡顿，还没有动态滚动效果的。

**解决：早期适配框架  iscroll 但这个框架已经不再维护了  有人参考了这个框架写了 better-scroll   有人维护，依赖于原生JS, 不依赖于其他框架**

+ 小技巧：开源框架的源码怎么找，

  + 如果官方网站没有下载，去github上面，找到tag版本进行下载，dist文件夹里esm.js里面。
  + 直接用命令行。版本是1.13.2

  ```
  npm install better-scroll@1.13.2 --save
  ```

+ ##### 在Category组件里这样做（实验），局部区域滚动的原生做法 #####

  + 首先整体的原生滚动：

  ```
  <template>
    <ul>
  	此处用ul包裹100个li
  	</ul>
  </template>
  ```

  + 可以实现滚动的，这是原生的。如果我想实现局部区域滚动，应该怎么做？

    +  方法1：给父标签最外层的div一个高度，再让整个区域overflow-y: scroll;   此时超过height之后的内容隐藏了,并且高度之内的可以实行滚动，局部滚动实现 。但原生滚动非常卡顿，框架的滚动怎么做呢？

    ```
    	height: 100px;
        background-color: red;
        overflow-y: scroll;  
    ```

    + 方法2：用框架来做
      <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204154344774.png" alt="image-20201204154344774" style="zoom: 50%;" />

  ```
  <template>
  //最外层需要包裹一个东西，并且有高度。之后往里面放入内容。但是content只能再放一个标签，一个！！
    <div class="wrapper" ref = "aaa">
    <ul>
  	此处用ul包裹100个li
  	</ul>
    </div>
  </template>
  
  ```

  ```
  <style>
    .wrapper {
      background-color: red;
      height: 200px;
      overflow: hidden;
      //此处只是将溢出的地方进行隐藏
    }
  </style>
  ```

  ```
  <script>
  import BScroll from 'better-scroll'
  export default {
    name: 'Category',
    // created() {
    //   组件创建完之后调用，但是还没有进行模板的挂载，
    //   所以这里的第一个参数是拿不到的。我们可以打印一下undifined/null
    //   console.log(this.$refs.aaa)
    //   console.log(document.querySelector('.wrapper'))
    //   this.scroll = new BScroll('.wrapper')
    // },
    data() {
      return {
        scroll: null
      }
    }
  }
  </script>
  ```

  + 犯错1：

    + 我们加了一个wrapper的div。把之前的高度样式给wrapper。这样还是不行

    + 导入安装的框架，并在created函数中new BSroll (参数1)，参数1是获取的dom节点。还是不行

    + 在data里初始化scroll，用于对new出来的数据进行保存，还是不行。

    + wrapper的那个标签添加 ref = “aaa”，更改new Scroll

    ![image-20201204155650488](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204155650488.png)

  + 犯错原因：在created里创建BScroll对象，这时拿不到dom节点，改在mounted里实现
    ![image-20201204155743073](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204155743073.png)

    ```
    mounted () {
        // 改为在mounted函数里去实现
        console.log(this.$refs.aaa)
        //这里可以写.类名，也可以用获取dom节点，插件会自动找到的
        console.log(document.querySelector('.wrapper'))
        this.scroll = new BScroll('.wrapper'),{}
      },
    ```

+ ##### Better-scroll的进一步拓展 #####

  + 拿到better-scroll下载打包之后的文件，使用它。也可以这样做，到node_modules里面的better-scoll 拿到dist文件夹下面的bscroll.js文件，粘贴过来

  + 随便一个地方新建index.html,导入这个JS文件

    ```
      <style>
        .content{
          height: 500px;
          background-color: red;
        }
      </style>
      <script src = './bscroll.js'></script>
    ```

    ![image-20201204161344411](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204161344411.png)

    ```
    <body>
     <div class="content">
    	<ul>
    	//这里也放100个li
    	</ul>
     </div>
    <script>
      // 里面有个叫做 BScroll  的类 ，打印结结果显示他是一个构造函数
      // console.log(BScroll);
      //哪个元素挂载上去实行滚动，就把他挂载上去。wrapper里面只能有一个元素。
      const bscroll = new BScroll(document.querySelector('.content'), {
      });
    </body>
    
    ```

  + 想要实时监听用户滚动到哪个位置了，滚动多少了？？怎么做，

    + 必须知道滚动到哪一个位置，详情，流行那个栏目才停留。拿到better-scoll对象后，通过on功能进行监听。

  ```
  // 第一个参数是要监听的类型，第二个参数是function，可以用箭头函数，函数的参数是position
  bscroll.on('scroll', (position) => {
    //position 是实时位置
    console.log(position)
  })
  //但是并没有打印出来，这是为什么呢？默认情况下，better-scroll是不可以实时监听滚动位置的。
    //想要做到，在new一个BScroll时还要传参数。重要属性：probeType  
  ```

  解决：修改传入的参数2，属性probeType

  ```
  const bscroll = new BScroll(document.querySelector('.content'), {
  //要不要实时侦测  0或1--不侦测  
  //2--侦测 手指滚动的过程中个侦测，但手指离开后的惯性滚动不侦测，其他情况，手指离开的滚动也可监听到
      probeType: 3,
    });
  ```

  <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204163108700.png" alt="image-20201204163108700" style="zoom:50%;" />

  + 属性2： 在better-scroll里面的如果是button，无论Click是true还是false都是可以点击的，但div那些组件就必须设置true才能添加监听事件

  + 上拉加载更多思路：属性3：pullUpLoad
    效果，我滚动到底，会进行打印

    ```
     const bscroll = new BScroll(document.querySelector('.content'), {
      		probeType: 3,
        // 监听已经拉到第一页最低部了，我们要做上拉加载更多的功能pullUpLoad
        	pullUpLoad: true
      });
    ```

  + 但有一个问题：只能监听一次，只能加载一次，怎么办
    先去发送网络请求，请求更多页的数据。等你数据请求完成并且将新的数据存储在list里展示出来后
    调调用一个函数，告诉它这一次的上拉加载已经做完了。进行下一次的上拉加载

    ```
    bscroll.on('pullingUp', () => {
      //这个函数没有参数，只是这里需要进行上拉加载更多了
      console.log('上啦加载更多')
      //为了不那么频繁进行下一次，设置一个定时器
      setTimeout(() => {
        console.log('我延迟了4秒');
        bscroll.finishPullUp()
      }, 3000)
    })
    ```

  + 我容易犯错的地方：
    这些属性的使用不够熟练，默写容易露着漏那

+ ##### 对Better-scrolld进一步封装 #####

  + 进一步的封装与抽离。首先将Scroll的功能封装在组件Scroll.vue里，目的解耦合。每个组件都用，对这个框架依赖性太强了。所以先封装，需要的组件只需要引入封装就可以。框架改变时，只需要修改封装就可以，而不需要每个组件都修改。这种公司向跟网络请求的封装也是一样的。

    封装操作思想：  封装在components里面，因为它能在多个地方进行使用的。common里面scroll

    文件夹，下一个项目中只要是滚动相关的项目，他也是可以拿来用的。Scroll.vue

    + 首先他也要有外层包裹，并满足包裹里面只能有一个；

    + 在mounted里面不建议用document.querySelector('.wrapper)
          // 通过选择器拿到的，如果有重复类名，没有办法区分拿到的是哪一个，结果可能不准确，
          // 因此造成bug，Vue 也不建议去直接操作Dom。怎么办呢？绑定ref,传入this.$refs.wrapper ref如果是绑定在组件中的，通过$refs.名字拿到的是一个组件对象。

      ref如果是绑定在普通标签中的，通过$refs.名字拿到的是一个元素对象。跟document.querySelector一样

    + 此外为了其他子组件调用的时候可以自由决定要不要实时刷新功能、要不要上拉加载更多的功能。我们对BScroll对象里面要传入的参数不是像之前写死的。而是从父组件接收过来的数据来决定

    + 在实时监听和上拉加载更多事件中，采用向外触发$emit事件，根据需要决定是否携带参数传出去。

      告诉要监听的组件，以便他们进行需要的处理和信息

    + 在methods里面，对我们创建的scroll对象里面自带的方法进行了封装，这样做是多此一举吗？
      1.封装思想；  2.为了简化父组件获取子组件中的scroll对象，再获取他的方法

  + ```
    <template>
      <div class="wrapper" ref = "wrapper">
        <!-- 以前的ref 父组件获取某一个子组件 -->
        <!-- 必须有包裹，因为better-scroll里面只能有一个 -->
        <div class="content">
          <!-- 这里设置插槽的目的：方便首页 -->
          <slot></slot>
        </div>
      </div>
    </template>
    
    <script>
      import BScroll from 'better-scroll'
      export default {
        name: 'Scroll',
        data() {
          return {
            scroll: null
          }
        },
        props: {
          probeType: {
            type: Number,
            default() {
              return 0
            }
          },
          pullUpLoad: {
            type: Boolean,
            default() {
              return true
            }
          }
        },
        mounted(){
          //创建BScroll对象
          this.scroll = new BScroll(this.$refs.wrapper, {
            //根据传入的来决定是否实时监听
            probeType: this.probeType,
            pullUpLoad: this.pullUpLoad,
          })
          this.scroll.on('scroll', (position) => {
            // 子组件向外发送位置信息，和事件
            this.$emit('scroll', position)
          })
          this.scroll.on('pullingUp', () => {
            this.$emit('pullingUp')
          }) 
        },
        methods: {
         scrollTo(x, y, time) {
           this.scroll.scrollTo(x, y, time)
         },
         //对完成上拉加载更多进行封装
         finishPullUp() {
           this.scroll.finishPullUp();
         }
        }
      }
    </script>
    ```

  + Home组件中，滚动区域高度的确定，上面留44和下面高度留49

    ```
      .content {
        height: 300px;
        position: absolute;
        top: 44px;
        bottom: 49px;
        right: 0;
        left: 0;
       }
        #home {
        /* 如果这里没有44px,轮播图会跑到最上面，他的一部分就会被导航栏遮盖 */
        padding-top: 44px;
        position: relative;
    ```

    + 遇到的问题： 图片被循环滚动？怎么解决、？？
      <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204215545273.png" alt="image-20201204215545273" style="zoom:33%;" />

      ```
      原因： 在Scroll.vue里面我用了4次插槽，这会导致将scroll包裹的东西重复了4次
      <template>
        <div class="wrapper" ref = "wrapper">
          <!-- 以前的ref 父组件获取某一个子组件 -->
          <!-- 必须有包裹，因为better-scroll里面只能有一个 -->
          <div class="content">
            <!-- 这里设置插槽的目的：方便首页 -->
            <slot></slot>
            <slot></slot>
            <slot></slot>
            <slot></slot>
            <slot></slot>
          </div>
        </div>
      </template>
      ```

    + 新产生的问题： 就是TabControl组件的粘连定位效果已经失效了，为什么呢？怎么解决？

      better-scroll在滚动的时候，系统没有办法检测现在滚到哪里了，所以sticky失效了。待解决

      

      

+ 需求1： 底部增加回到顶部的按钮，封装在components的content里面BackTop.vue

  <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201204201503011.png" alt="image-20201204201503011" style="zoom:50%;" />

  ​    往下拉轮播图，为什么图标在没有布局时会跑到这里，因为从轮播图开始下面的东西是脱标的，图标就会被覆盖掉。而且我们顶部导航栏有一个padding-bottom  所以图标从下面导航栏下面开始占据位置。但我希望他在右下角，fixed布局。而且很多个页面这个图标都是在右下角这个位置，我们在这个组件里提前设置好

  ```
  <template>
  <!-- 这里面封装的就是一个返回顶部的小图片 -->
    <div class="backtop">
      <img src="~assets/img/common/top.png" alt="" >
    </div>
  </template>
  
  <script>
    export default {
      name: "BackTop",
    }
  </script>
  
  <style scoped>
    .backtop {
      position: fixed;
      right: 6px;
      bottom: 60px;
    }
    .backtop img {
      width: 43px;
      height: 43px;
    }
  </style>>
  ```

+ 需求2：如何完成位置跳转：拿到Better-scroll对象，里面有一个scrollTo(x, y)方法，传入参数就可以跳转到我们想要的位置。在哪个组件里实现这个功能，

  + 方案1：不要在图标组件里完成跳转到顶部，因为顶部是父组件Home里的，而图标组件和Scroll组件都是Home组件的子组件。此时需要图标组件触发，Home那边组件监听，再用methods想办法拿到Srcoll组件里的Bette-scroll对象，再去调用这个方法。这样做很麻烦
  + 更好的做法： 直接监听Home里面的back-top组件的点击事件，这在普通标签上是当然可以的，但组件是否可以直接不通过子组件向外触发事件，父组件监听的方式，而是父组件直接监听呢？？
    答案是：不可以直接监听点击，必须借助.native修饰符，才可以监听组件根元素的原生事件。如果不加，只能按照方案1，但是方案1比较麻烦

+ 问题2： 如何获取到scroll对象，给scroll根组件绑定ref，再通过this.$refs.Scroll()拿到组件对象，再拿到组件对象的属性

  ```
  Home组件中：
  <scroll class="content" ref="scroll" :probe-type = "3" >
  <back-top @click.native="backTop" v-show = "isBackTop"></back-top>
  data里：isBackTop: false
  方法里：backTop() {
        // //拿到scroll组件上的scroll对象，调用他的scrollTo方法,第三个参数是多长时间回位置
        // this.$refs.scroll.scroll.scrollTo(0, 0, 500)
        // 这样写是拿到scroll组件，直接调用组件的方法，这个方法内部做了什么，在Scroll中已经定义了
        this.$refs.scroll.scrollTo(0, 0, 500)
      },
  ```

+ 需求3：达到某个临界值时，图标显示，没到某个临界值，图片隐藏。所以我们需要实现监听图片滚动了多少，怎么监听呢？？？

  ```
  Home组件进一步修改：
  <scroll class="content" ref="scroll" :probe-type = "3" 
            @scroll = "contentScroll">
   方法里：        
  	contentScroll(position) {
        //从position里取出y值，与1000对比，大于显示图标，小于隐藏图标
        //y默认是负值，要转换成正值，跟1000对比
        this.isBackTop = (-position.y) > 1000 ?true: false  
      }
  ```

+ 需求4： 上拉加载更多图片，此时我们需要再进行数据请求


+ 首页Better-scroll可滚动区域问题：

现象：图片异步加载，每一项组件的高度被撑开了，可滚动区域突然变得更大了，但是这个插件并不知道，他还是按照没有图片时的可滚动区域。这时再往下滚就滚动。所以，我们要1.监听图片加载完，进行刷新。2.拿到srcoll对象调用refresh方法。一旦调用refresh就是真实可滚动高度

解决：

  打印new BScroll出来的 scroll对象，控制台查看里面有个属性叫scrollerHeight，根据放在better-scroll的cntent在子组件的高度决定当前有多少区域是可滚动的。这个高度没有计算加载图片的高度。所以我们滑到最后会有一片空白。图片异步加载，每一项组件的高度被撑开了，可滚动区域突然变得更大了，但是这个插件并不知道，他还是按照没有图片时的可滚动区域。这时再往下滚就滚动。所以，我们要

+ 1.监听每张图片加载完，进行一次刷新。图片绑定加载事件，一旦图片加载完成就会执行这个函数

问题怎么知道30张图片已经加载完成了呢？也就是如何图片加载完成与refresh对应起来
![image-20201205185556938](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201205185556938.png)

2.拿到srcoll对象调用refresh方法。一旦调用refresh就是真实可滚动高度。但是这个refresh是scroll对象的方法，现在在GoodListItem子组件里，是不能直接调用另一个组件的方法的。解决办法：GoodListItem先传给GoodList，再传给首页，首页再给Scroll组件。但这样很麻烦。

方法2：搞一个Vuex,每次图片加载完之后，就改变Vuex里面的属性。再让首页引用这个属性并监听这个属性的改变。

方法3：事件总线。与Vuex很像，但是他不是管理公共状态的，是用来管理事件的。this.$bus.$emit('aa'),可以往Bus里面发送一个事件aa，之后在想要监听的位置写 this.$bus.$on('aaa', 函数)  

```
    methods: {
      imageLoad() {
        this.$bus.$emit('itemImageLoad')
      }
    }
```

Home组件中监听：

```
  created () {
    this.getHomeMultidata()
    //我们希望3个页面在开始的时候都是请求第一页
    this.getHomeGoods('pop')
    this.getHomeGoods('new')
    this.getHomeGoods('sell')

    //等组件创建完成之后就要监听你的图片是不是加载完成了
    this.$bus.$on('itemImageLoad', () => {
      console.log('我知道你的图片加载完成啦')
    })
```

+ 但是会报错： 因为bus不存在。必须在原型里面加上。去main.js里面，给Vue原型方法上加上$bus

```
//此时$bus就是事件总线
Vue.prototype.$bus = new Vue()
```

图片加载完后，给总线触发了事件，Home组件在created中监听。监听到后调用scroll组件里面的refres方法。但是scroll对象的创建在Scroll.vue组件里在mounted的时候创建的。这是后拿到的scroll可能是空的。对Scroll方法进行修改，

```
     scrollTo(x, y, time) {
       //在这里先做判断，scroll是不是有值
      //  this.scroll && this.scroll.scrollTo(a,y,time)
      //  this.scroll.scrollTo(x, y, time)
     },
     refresh() {
       this.scroll && this.scroll.refresh();
      //  this.scroll.refresh();
    },
```

在Home组件里也做同样修改。

```
  mounted() {
    //等组件创建完成之后就要监听你的图片是不是加载完成了
    this.$bus.$on('itemImageLoad', () => {
      this.$refs.scroll && this.$refs.scroll.refresh();
    })
  },
```

防抖动/debounce：防抖函数，在用户输入一个值，等待50ms，看是否还输入值，若继续输入，将上一次准备像服务器发送的请求取消掉。将这两个东西收集起来，若500ms之后没有继续输入。这就防止了短时间内向服务器发送多次请求，缓解服务器的压力。

这里每次加载图片都进行刷新refresh，所以也应该做防抖处理。这样加载一次要刷新30次。通过debounce函数将refresh函数传入到debounce中生成一个新的函数。

this.debounce ()

```
    debounce(func, time) {
      let timer = null;
      //这里剩余参数，可以传多个参数
      return function(...args) {
        if (timer) {clearTimeout(timer)}
         timer = setTimeout(() => {
         //改变this指向，拿到当前函数的参数
           func.apply(this, args)
         })
      }
```

1.判断是否有timer，第一次没有值，null。延迟500ms执行。但是图片加载调用很频繁。所以延迟的过程中第二次来到这个函数。此时timer不是空的了，看赋值表达式。所以会将timer1清空掉。再给timer重新赋值。到第29次一样。但是第30次之后，因为没有31次了，不会再来到这个函数里面了，定时器时间一到。拿到function了。执行函数里面的函数，applay拿到当前的所有传入参数
为什么不传参数delay，也能试下防抖呢？
事件循环机制：因为只要实现setTimeOUt是异步函数，即使没有延迟时间，会放到事件队列的尾部等到执行栈里执行完成之后才执行时间队列里的任务

```
  mounted() {
        //传入的是函数，不是函数返回值
        // 这里的refresh变量不会被销毁，因为被闭包引用
    const refresh = this.debounce(this.$refs.scroll.refresh, 10)
    //等组件创建完成之后就要监听你的图片是不是加载完成了
    this.$bus.$on('itemImageLoad', () => {
       this.$refs.scroll && this.$refs.scroll.refresh();
         //在这里调用refresh的过程：
    })
  },
```

节流函数/throttle：





对节流函数封装在common文件夹中，起名字Utils.js，并导入Home组件，则使用时就不需要加this了

```
export function debounce(func, time) {
  let timer = null;
  //这里剩余参数，可以传多个参数
  return function(...args) {
    if (timer) {clearTimeout(timer)}
     timer = setTimeout(() => {
     //改变this指向，拿到当前函数的参数
       func.apply(this, args)
     })
  }
}
```

```
import {debounce} from 'common/Utils.js'
```

+ ##### 需求5：上拉加载更多 #####

  + 监听什么时候滚到底部，scroll组件中的pullUpLOad属性值是外部决定的，让外界传入一个属性

    ```
          pullUpLoad: {
            type: Boolean,
            default() {
              return false
            }
          }
        },
    ```

    Home组件中对scrol添加绑定属性：

    ```
        <scroll class="content" ref="scroll" :probe-type = "3" 
    				 @scroll = "contentScroll"   :pull-up-load = "true"
          </scroll> 
    ```

    在mounted里面监听 

    ```
          if (this.pullUpLoad){
            this.scroll.on('pullingUp', () => {
            this.$emit('pullingUp')
          })
          }
    ```

    因为上拉到底时，我们首页要将即将加载的数据请求过来，所以首页Home组件要监听这个事件，并进行数据请求。currentType记录了当前选中的类型pop，根据pop取出pop当前页码。里面会将第二页数据拿到。放到list里面。并加页码

    ```
        <scroll class="content" ref="scroll" :probe-type = "3" 
                @scroll = "contentScroll"   :pull-up-load = "true"
                @pullingUp = "loadMore"
                >
    
    methods里面：
        loadMore() {
          //currentType记录了当前是哪一项。我们就获取哪一项的数据。取出当前的页码并加上1，
          // 如果继续上拉加载更多，页码继续增多
          console.log('首页知道你到达底部啦')
          this.getHomeGoods(this.currentType)
        }
    ```

    + 问题：pullUpLoad默认只加载一次，还需要finish函数。在数据加载完之后，告诉他已经完成了上拉加载更多

    ```
        getHomeGoods(type) {
          // 这个+1，这是告诉他要请求的是哪个页码的数据
          const page = this.goods[type].page + 1
          getHomeGoods(type, page).then(res => {
             console.log(res);
            this.goods[type].list.push(...res.data.list);
            // 而这个地方的+1，则是我们已经有两页数据了，当前页码应该更新到2了，而不是之前的1
            this.goods[type].list.page +=1;
            // //调用scroll里面的方法
            this.$refs.scroll.finishPullUp();
          })
    ```

    ```
    Scroll组件中，    //对完成上拉加载更多进行封装
         finishPullUp() {
           this.scroll.finishPullUp();
         },
    ```

  ### 9.TabControl的吸顶效果 ###

  #### 之前有sticky实现，但是在后面改需求后，又失效了。现在怎么解决呢？ ####

  <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201210195522021.png" alt="image-20201210195522021" style="zoom:50%;" />

  1.判断向上滚动的距离，如果大于某个距离，就开始吸顶（改布局fixed等）

  + 怎么确定这个阈值呢？获取TabControl的offtop属性。一般情况下轮播图加载完了，他就拿到的是一个比较正确的值。
    项目中经常需要监听图片是否加载完，否则他的加载会对你获取的数据有影响。
    去HomeSwiper组件里，为图片绑定@load事件监听，，并向外$emit触发事件

  ![image-20201206221918886](C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20201206221918886.png)

  ```
     绑定对HomeSwiper组件上的监听： swiperImageLoad
     swiperImageLoad() {
        //打印结果
        // this.$refs.scroll && this.$refs.scroll.refresh();
        // 右侧拿到的是组件对象，组件有没有属性叫offsetTop呢？答案是没有
        // 所以我们应该去拿组件里的模板，是元素里面才有这个属性
        // 所有的组件都有一个属性叫$el，这个属性是用于获取组件中的元素的
        // this.tabOffsetTop = this.$refs.tabControl;
        this.tabOffsetTop = this.$refs.tabControl.$el.offsetTop;
        // 但这样数值结果是不对的，因为mounted里挂载以为这组件都挂载上面了，
        //但是图片未必都加载完了.等上面的图片都加载完毕再去拿这个offsetTop才是对的
      }
  ```

  每张轮播图加载后都会取一次offsetTop，其实只需拿一次就可以拿到高度。我就知道高度了。你后面图片的加载就不要再发送这个事件告诉HOME组件了，因为有第一次的发送能拿到offsetTop。HomeSwiper修改：

  ```
      methods: {
        imageLoad() {
          //若图片还没有加载
           if (!isLoad) {
             this.$emit('swiperImageLoad');
            //  这样在第二次加载的时候他就不会来到这个函数里面了
             this.isLoad = true
           }
        }
      },添加：
      data() {
        return {
          isLoad: false
        }
      }
  ```

  2.在Home组件里面contentScroll里，决定要不要吸顶

  ```
      contentScroll(position) {
        //从position里取出y值，与1000对比，大于显示图标，小于隐藏图标
        //y默认是负值，要转换成正值，跟1000对比
        this.isBackTop = (-position.y) > 1000 ?true: false
        //决定是否吸顶，当前滚动距离是否大于tabControl距离顶部的高度，就吸顶
        this.isTabFixed = (-position.y) > this.tabOffsetTop
      },
  ```

  ```
      帮上新属性class,动态决定要不要加一个fixed：    
      	<tab-control :titles = "titles" 
                        class="tab-control" 
                        @tabClick="tabClick"
                        :class = "{fixed:isTabFixed}">
          </tab-control>
  
    .fixed {
      position: fixed;
      top: 0;
      right: 0;
      left: 0;
    }
  ```

  + 新问题： TabControl一下子往上面跑一下，因为它脱标了，所以下面的东西一下子跑上面去了。继续往下滑，这个栏目消失了。Better-scroll在滚动中的过程中，会往content上加很多属性。其中Translate属性在滚动的过程中，会不断地改变，所以滚动是通过修改Translate实现的。里面有一个fixed的东西是可以修改translate的。所以，Better-scroll里面的停留效果不好做，粘贴tab-control，到nav后面，scroll外面。并添加v-show = "isTabFixed"  isTabFixed默认值是false

  + ```
        <tab-control :titles = "titles" 
                      class="tab-control" 
                      @tabClick= "tabClick"
                      :class = "{fixed:isTabFixed}"
                      v-show = "isTabFixed">
        </tab-cotrol>
    ```


  默认情况下，他是false的，当滚到要显示那个地方，他就出现。并将原有的覆盖。用户看起来好像停留在这里了。

  + 新问题：点击新款，并没有更新，说明这两个TabControl并没有保持一致
    我们只需要拿到tabControl，它里面的currentIndex记录了当前选中的是哪个类型。所以 两个tabControl设置不同的tabControl2。在监听点击的位置，等点击完成之后，this.$refs.tabControl1.currentIndex

    ```
        tabClick(index) {
          // console.log(index)
          switch (index) {
            case 0: this.currentType = 'pop'
            break
            case 1: this.currentType = 'new'
            break
            case 2: this.currentType = 'sell'
            break
          }
          //index 是最新点击的。更新index
          this.$refs.tabControl1.currentIndex = index;
          this.$refs.tabControl2.currentIndex = index;
        },
    ```

  + 一直困扰我的问题：首次进入页面：轮播图没有效果。但切换其他页面再切换回来，又显示了？？？？

    

  + 为什么加载底部会有大片空白？？为什么切换是，没有对应图片展示？？有时出现，大多数时候没

  

  + 没有办法切换 流行，首页，数据，但是组件在scroll外面可以，里面就可以(原因是上面代码中两个index赋值都给了tabControl1，写错了)

+ #### 遇到的问题：当我们离开首页后，再回来，如果很快就回来，会保持离开时的浏览位置。但如果稍微慢一点，再进来就回到了最开始。 ####

  + 原因：这些组件都是通过路由来实现管理的，当跳转到分类页，首页就销毁了。所以我们再进入的时候Home又重新创建。解决：对App.vue里面的router-view包裹一层keep-alive。但还是有问题，

    + 1.虽然Home组件没有被销毁，但better-scroll内部的问题导致效果并没有生效（安卓手机生效了）。

    + 2.我们要让Home中的内容保持原来滚动的位置。离开时保持一个位置信息，再进入的时候设置成之间的位置

    + 3.监听什么时候离开，activated和deactivated。一个是在进来，一个是在拉开的时候调用。

  + Home组件

  ```
      activated() {
      //进入的时候设置高度,x不需要滚动，也不需要几秒之内,应该是迅速回到原位置
          this.$refs.scroll.scrollTo(0, this.saveY, 0)
      //还要进行刷新，不然有时候会出问题。但我们在进来的时候滚动到原来的位置，并进行一次属性
          this.$refs.scroll.refresh();
    },
        deactivated() {
      // 离开的时候拿到高度进行保存
          // this.saveY = this.$refs.scroll.scroll.y  对这个获取做一层封装
      this.saveY = this.$refs.scroll.getScrollY() 
        },
  ```

  在scroll组件中：methods中封装函数

  ```
     getScrollY(){
        return this.scroll ? this.scroll.y : 0;
          },
  ```