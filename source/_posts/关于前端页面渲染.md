---
title: 关于前端页面渲染
date: 2021-12-13 17:16:38
tags: 页面解析渲染
categories: 浏览器
description: '页面加载解析渲染过程发生了什么'
cover: https://images.unsplash.com/photo-1512620230221-c041ac15d906?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=387&q=80
copyright_author: 飞儿 # 作者覆写
copyright_url: https://www.nesxc.com/post/hexocc.html 
license: CC BY-NC-SA 4.0
license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/
---

## 这部分的东西会结合JS的整个运行重新梳理，这个笔记不太满意

## 1、Webkit渲染流程 ##

浏览器获取到html，然后解析，渲染

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d69da20c3f84782948226798effc60a~tplv-k3u1fbpfcp-watermark.awebp" alt="img" style="zoom:50%;" />

### 1、DOM树构建 ###

```
Bytes → characters → tokens → nodes → DOM
```

#### 1、转换 ####

* 浏览器将获得的HTML内容是0/1这样的原始 `字节流`，根据文件的指定编码 (例如 UTF-8) 将它们转换成各个 `字符`

#### 2、分词 ####

* 进行 `词法解析` ，把字符流初步解析成我们可理解的 `词`，学名叫 `token`

* `词` 是编译原理中的最小单元，如标签开始、属性、标签结束、注释、CDATA节点

* `Tokens` 这个阶段中会标识出当前 `Token` 是 `开始标签` 或是 `结束标签` 亦或是 `文本` 等信息

  ```js
  <div class="haha">haha</div>
  ```

  ```js
  1. <div					# 哦，看到了<div，这是一个div标签的开始
  2. class="haha" # 这是一个class属性
  3. >						# 哦，到这儿是一个完整的div开始标签
  4. haha					# 嗯，这是一个文本
  5. </div>				# 奥，看到了</div>，整个div标签结束了
  ```

  <img src="https://segmentfault.com/img/remote/1460000013662139" alt="img" style="zoom: 67%;" />

#### 3、节点创建 ####

* 在每个 `Token` 被生成后，会立刻消耗这个 `Token` 创建出节点对象，就是 节点 (Nodes) 阶段
* 把开始结束标签配对、属性赋值好、父子关系这些都连接好了，最终就构成了 `DOM` 树
* 到此 `DOM Tree` 就解析完了

### 2、解析CSS—>CSSOM ###

* CSS规则树的生成也是类似

  ```
  Bytes → characters → tokens → nodes → CSSOM
  ```

  譬如`style.css`内容如下：

  ```
  body { font-size: 16px }
  p { font-weight: bold }
  span { color: red }
  p span { display: none }
  img { float: right }
  ```

  那么最终的CSSOM树就是：

  <img src="https://segmentfault.com/img/remote/1460000013662141" alt="img" style="zoom: 50%;" />

#### 2、CSS阻塞 ####

* 节点样式是可以继承的，所以在构建的过程中浏览器得递归 `DOM` 树来确定元素到底是什么样式
* 为了 `CSSOM` 的完整性，只有等构建完毕才能进入到下一个阶段，所以就算 `DOM` 已经构建完了，也得等 `CSSOM`，在 CSSOM 构建完毕之前，不会渲染任何已处理的内容

* 所以 `CSS` 的加载速度与构建 `CSSOM` 的速度**会影响首屏渲染速度**，这就是常说的 `CSS` 资源的加载会阻塞渲染

### 3、解析JS脚本 ###

#### 1.1、JS既会阻塞HTML、CSS的解析 ####

* 解析 `JS` 的步骤是不固定的，因为在构建DOM 树的过程中，当 `HTML` 解析器遇到一个 `script` 标记时，**即遇到了js，立即阻塞DOM树的构建**

* 就会将控制权移交给 `JS` 引擎，等到 `JS` 引擎运行完毕，浏览器才会从中断的地方恢复DOM树的构建

* 设计的原因：JS可以对DOM操作节点，浏览器无法预测未来的DOM节点的具体内容，**为了防止无效操作，节省资源，只能阻塞DOM树的构建**

  假如不阻塞，若 JS 删了某个DOM节点A，那么浏览器为构建此节点A花费的资源是无效的

* **遇到img图片类资源**

  直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方

#### 1.2、优化： ####

1. 尽量将JavaScript文件放在body的最后

   若在 HTML 头部加载 JS 文件，由于 JS 阻塞，会推迟页面的首绘，所以为了加快页面渲染，一般将 JS 文件放到HTML 底部进行加载

2. script标签引入：对 JS 文件执行 `async` 或 `defer` 加载

   * `script`立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；
   * `async` 是下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；一定在 `onload` 前，但不确定在 `DOMContentLoaded` 事件的前或后
   * `defer` 是加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行，所以在浏览器看起来的效果像是将脚本放在了 `body` 后面一样，按规范应该是在 `DOMContentLoaded` 事件前，但不同浏览器不同

##### loaded/domcontentloaded #####

* `DOMContentLoaded` ：仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)，所以js可以访问所有DOM节点，初始化界面
* `load `：页面上所有的DOM，样式表，脚本，图片都已经加载完成了
* `unload` -- 当用户离开页面的时候触发，可以询问用户是否保存了更改以及是否确定要离开页面,，可是我们无法阻止用户转移到另一个页面上。

* `beforeunload`:用户即将离开页面或者关闭窗口时，beforeunload事件将会被触发以进行额外的确认
* `document.readyState`表征页面的加载状态，可以在`readystatechange`中追踪页面的变化状态：
  * `loading` — 页面正在加载中。
  * `interactive` -- 页面解析完毕，时间上和 `DOMContentLoaded`同时发生，不过顺序在它之前。
  * `complete` -- 页面上的资源都已加载完毕，时间上和`window.onload`同时发生，不过顺序在他之前

#### 2.1、CSS阻塞页面渲染 ####

使用CSS有三种方式：使用**link、@import、内联样式**，其中link和@import都是导入外部样式。它们之间的区别：

* **link**：浏览器会派发一个新等线程(**HTTP线程**)去加载资源文件，**与此同时GUI渲染线程**会继续向下渲染代码
* **@import**：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(**阻碍浏览器渲染**)
* **style**：GUI直接渲染，减少关键渲染资源从服务器端到客户端的往返次数，因为不用link那样请求

* 外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。

* 所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。

**针对DOM树、CSSOM树：** 可以通过以下几种方式来减少渲染的时间：

* HTML文件的代码层级尽量不要太深
* 使用语义化的标签，来避免不标准语义化的特殊处理
* 减少CSSD代码的层级，因为选择器是从左向右进行解析的

#### 3、 CSS 如何阻塞JS脚本执行？ ####

* JS脚本执行时**可能在文档的解析过程中请求样式信息**，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。
* 所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将**延迟 JS 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建**
* 在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JS，最后再继续文档的解析。

### 4、构建render树 ###

#### 1、构建顺序 ####

* 渲染树 由 `DOM树`、`CSSOM树` 合并而成，但并不是必须等 `DOM树` 及 `CSSOM树` 加载完成后才开始合并构建 `渲染树`
* 三者的构建并无先后条件，也并非完全独立，而是会有交叉，并行构建，因此会形成一边加载，一边解析，一边渲染的工作现象
* 渲染树的节点被称为**渲染对象**，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，**不可见的 DOM 元素不会被插入渲染树**。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。

#### 2、render树构建流程 ####

1. 浏览器首先会从DOM树的根节点开始遍历每个可见节点
   * 例如脚本标记、元标记等有些节点不可见，因为它们不会体现在渲染输出中，所以会被忽略
   * 某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如上图的其中一个 `span` 标签有 `display: none` 属性，也会被忽略
   * 一般来说，渲染树和DOM树不是严格对应。因为有一些不可见的DOM元素不会插入到渲染树中，如**head这种不可见的标签**或者`display: none`等
2. 对于每个可见节点，找到其对应的的 CSSOM 规则并应用它们
3. 输出可见节点，连同其内容和计算的样式

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/22/1719d8c1564c3947~tplv-t2oaga2asx-watermark.awebp" alt="image-20200418220809467" style="zoom:67%;" />

### 5、布局阶段 ###

* 至此，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们还没有计算它们在设备 [视口](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fdesign-and-ux%2Fresponsive%3Fhl%3Dzh-cn%23set-the-viewport) 内的确切位置和大小，而这就是 `布局` ( Layout ) 阶段，也称为 `回流` ( Reflow )

* 此阶段一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树
* 布局流程的输出是一个 `盒模型`，它会精确地捕获每个元素在视口内的确切位置和尺寸，当然，所有相对测量值都转换为屏幕上的绝对像素

### 6、绘制 ###

* 由前几步我们知道了哪些节点可见、它们的计算样式以及几何信息，我们将这些信息传递给最后一个阶段将渲染树中的每个节点转换成屏幕上的实际像素，也就是俗称的 `绘制` 或 `栅格化`

#### 1、重绘 ####

* 元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了，这叫做 `重绘` ( Repaint )
* outline, visibility, color, background-color等

#### 2、回流 ####

* 一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树

* #### 回流的场景： ####

  ```
  1.页面渲染初始化
  2.DOM结构改变，比如删除了某个节点
  3.render树变化，比如减少了padding
  4.窗口resize，字体大小会引起回流!!!
  5.最复杂的一种：获取某些属性，引发回流，很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括
      （1）offset(Top/Left/Width/Height)
       (2) scroll(Top/Left/Width/Height)
       (3) cilent(Top/Left/Width/Height)
       (4) width,height
       (5) 调用了getComputedStyle()或者IE的currentStyle
  ```

#### 3、如何减少和避免回流重绘 ####

其实就是尽量避免上面那些操作

* 减少逐项更改样式，最好一次性更改 `style`，或者将样式定义为 `class` 并一次性更新
* 避免循环操作DOM，让DOM离线后再修改
  * 创建一个 `documentFragment` ，在它上面应用所有DOM操作，最后再把它添加到 `window.document`
  * 先把DOM节点 `display:none` ( 会触发一次回流)，然后做修改后，再把它显示出来
  * 克隆一个DOM节点在内存里，修改之后，与在线的节点相替换
* 避免多次读取offset等属性，无法避免则将它们缓存到变量
* 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高
* 改变字体大小也会引发回流，所以尽可能减少这种操作
* table布局，一个小改动会造成整个table的重新布局，所以，少用为好

### 7、合成 ###

到目前我们经历渲染过程如下

* 首先解析 `HTML` 文档，形成 DOM 树
* 接着解析 `CSS`，产生 CSSOM树
* 在DOM和CSSOM树解析过程中，遇到 JS，会立即阻塞DOM树的构建，JS解析完成，接着走上面两步
* 再接着，浏览器通过DOM和CSSOM树构建渲染树 
  * 这个过程中，DOM中不可见标签元素不会放到渲染树中，就像` 或 display:none`
  * CSSOM树规则会附加给渲染树的每个元素上
* 渲染树构建完成，浏览器会对这些元素进行定位和布局，这一步也叫 重排/回流 ( `Reflow`) 或 布局(`Layout` )
* 接下来绘制这些元素的样式，颜色，背景，大小及边框等，这一步也叫做 重绘 (`Repaint`)
* 再接下来是我们这最后一步合成( `composite` )，浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上

### 8、浏览器渲染方式 ###

浏览器在渲染图形的时候，有一个绘图上下文，绘图上下文又分成两种类型

* 第一种是用来绘制2D图形的上下文，称之为2D绘图上下文
* 第二种是绘制3D图形的上下文，称之为3D绘图上下文

网页也有三种渲染方式

* 软件渲染（CPU内存）
* 使用软件绘图的合成化渲染（GPU内存）CSS3D、WebGL
* 硬件加速的合成化渲染（GPU内存）

#### 1、软件渲染技术 ####

Webkit 在不需要硬件加速内容的时候（包括但不限于 `CSS3 3D变形`、`CSS3 3D变换` 、 `WebGL` 和 `视频`），它就可以使用 `软件渲染技术` 来完成页面绘制

对于每个渲染对象，需要三个阶段绘制自己

* 第一阶段是绘制该层中所有块的背景和边框
* 第二阶段是绘制浮动内容
* 第三阶段是前景 ( Foreground ) ，也就是内容部分、轮廓、字体颜色、大小等 ( 内嵌元素的背景、边框等发生在这一阶段 )

#### 2、硬件加速技术 ####

硬件加速技术是指使用 GPU 的硬件能力来帮助渲染网页 ( GPU的作用主要是用来绘制3D图形并且性能很 nice )

#### 3、普通图层和复合图层 ####

浏览器渲染的图层一般包含两大类：`普通图层` 以及 `复合图层`

* **普通文档流：**

  叫它`默认复合层`，因为里面不管添加多少元素，其实都是在同一个复合图层中

  `absolute` 布局、 `fixed` 也一样，虽然可以脱离普通文档流，但它仍然属于 `默认复合层`

* **复合图层：**

  可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能

  但也不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡，因小失大

* GPU中，各个复合图层是单独绘制的，所以也互不影响

* 通过 `硬件加速` 的方式，会声明一个 `新的复合图层` ，它会单独分配资源，当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响 `默认复合层` 里的回流重绘

#### 4、何为复合图层/硬件加速 ####

复合图层或者说硬件加速，其实就是仅触发合成 `composite` ，那么也就必须符合以下三个条件

* 不影响文档流
* 不依赖文档流
* 不会造成重绘

可以做到这种情况得

* 最常用的方式是 `transform`

  假如我们给一个元素加了 `transform` 属性吧，那么该元素就不会影响也不会依赖文档流，也不会造成重绘，就变成了一个复合图层

  也就可以说我们对它使用了传说中的 `硬件加速技术`

* `opacity` 属性 / 过渡动画 (需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态)

* `will-chang` 属性 (这个比较偏僻)，一般配合 `opacity` 与 `translate` 使用，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层，作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作 (最好用完后就释放)

#### 5、absolute？ ####

 `absolute` 是脱离文档流，为什么上面复合图层或者说硬件加速中没有 `absolute` 呢？

* 其实，`absolute` 虽然可以脱离普通文档流，但是无法脱离默认复合层，就像它的 `left` 属性可以使用百分比的值，依赖于它的 `offset parent`
* 所以，就算 `absolute` 中信息改变时不会改变普通文档流中的 `渲染树` 
* 但浏览器最终绘制时，是整个复合层绘制的，所以 `absolute` 中信息改变，仍会影响整个复合层的绘制，浏览器还是会重绘它
* 如果复合层中内容多，`absolute` 带来的绘制信息变化过大，资源消耗也非常严重
* 硬件加速，那直接就是在另一个复合层了，所以它的信息改变不会影响默认复合层，当然内部肯定会影响属于自己的复合层，仅仅是引发最后的合成渲染

### 9、页面渲染优化 ###

总结下页面渲染这块的优化实践：

* HTML文档结构层次尽量少，最好不深于六层
* JS 脚本尽量后放
* 样式结构层次尽量简单
* 少量首屏样式使用内联方式放在标签内
* 在脚本中尽量减少DOM操作，尽量访问离线DOM样式信息，避免过度触发回流
* 减少通过 JS 代码修改元素样式，尽量使用修改 `class` 名方式操作样式或动画
* 尽量减少浏览器重排和重绘的一些情况发生
* 2020年了！就不要使用 `table` 布局了
* CSS 动画中尽量只使用 `transform` 和 `opacity` ，不会发生重排和重绘
* 隐藏在屏幕外，或在页面滚动时，尽量停止动画
* 尽可能只使用 CSS 做动画，CSS动画肯定比 JS 动画要好很多
* 避免浏览器的隐式合成
* 改变复合层的尺寸

### 10、如何优化关键渲染路径？ ###

为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：

（1）关键资源的数量。

（2）关键路径长度。

（3）关键字节的数量。

* 关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。
* 同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。
* 要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。

优化关键渲染路径的常规步骤如下：

（1）对关键路径进行分析和特性描述：资源数、字节数、长度。

（2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。

（3）优化关键字节数以缩短下载时间（往返次数）。

（4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度


