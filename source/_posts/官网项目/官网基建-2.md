---
layout: post
title: 官网基建(2)之webp转换插件
date: 2022-04-12 19:24:07
categories: 项目总结
tags:
  - 前端基建
  - webpack插件
  - webp图片
description: 官网基建(2)之webp转换、webpack插件
cover: https://cdn.jsdelivr.net/gh/myNightwish/CDN_res/blogskin/官网基建.webp
copyright_author: 飞儿
copyright_url: 'https://www.nesxc.com/post/hexocc.html'
license: CC BY-NC-SA 4.0
license_url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/'
abbrlink: basic_construct_2
---

## webpack插件实践踩坑及收获

> ### 前言
>
> 在开始今天的文章之前，依旧先交代下问题出现的背景（凑字数）：
>
> - 基于项目的性能提升的需要，我们需要将网站中所有图片png、jpg格式图片全部换成webp格式的；
> - 手动替换是不现实的，而npm包上并没有现成的符合我们需求的插件，基于此，决定自己写一个脚本，进而将脚本封装为webpack插件
> - 在此过程中，需要了解webpack插件机制，从而在合适的时机去执行脚本；
> - 完成插件后，我们还需要将本地项目中的.png后缀换成webp，否则项目跑不起来；手动替换显然有点Naive，于是需要写一个loader；
> - 基于以上需求，我们需要做的事：
>   1. 完成图片转换webp脚本的编写；
>   2. 完成脚本到plugin从插件的转换；
>   3. 编写loader替换原有的png代码；
>   4. 思考如何优化？
>      - 你希望本地运行时时期就执行转换吗？
>      - 还是说打包时，才做这件事，那么本地项目怎么跑起来；
>   5. 之前的一个优化：关于线上、线下资源部署路径导入问题，如何借助webpack解决这个问题
>      - loader与plugin的区别，什么时候用loader，什么时候用plugin
>      - 如何用loader解决这个问题
>   6. 最后，最近的开发让我有机会实践到了关于webpack的有关的知识，同时结合我日常打理博客的实践，想趁机捋一下这些概念都在做什么，相信有很多前端小白起初都会有一些懵懵懂懂的感觉

### 一、转换webp的脚本

> #### 关于插件版本：
>
> * ESModule导入方式：两个插件的高版本所支持的，
>
>   ```js
>   import imagemin from 'imagemin';  //  8.版本
>   import imageminWebp from 'imagemin-webp'; //  7.版本
>   ```
>
> * 此时为了脚本运行，在package.json中添加了，从而可以实现转换功能。
>
>   ```js
>   "type": "module"
>   ```
>
> * 但由于我需要将功能进一步封装为插件，于是，还需要配置webpack。然而Next中的webpack配置很多文件都是CJS导入，此时必须将这部分也换为CJS导入。但这种导入在高版本中不支持~需要两个不同低版本的搭配使用，而不能直接用最新版
>
>   ```js
>   const imagemin = require('imagemin');
>   const imageminWebp = require('imagemin-webp');
>   ```
>
> * 小教训：有问题多去issue，goole，少用中文，我的描述可能不准确

> #### 实现思路：
>
> - 从输入命令中读取指定的要转换的目录、得到路径、转换质量；
> - 递归读取文件目录下的jpg、png图片，借助插件，转换图片；
> - 每层完成转换后，继续往深处目录递归读取，知道完成所有的转换

> 脚本实现：

```js
async function recurConvert (dir) {
  const res = fs.readdirSync(dir, {withFileTypes: true});
  await imageMin([path.join(dir, '*.{jpg,png}')], dir, {
    plugins: [ imageMinWebp({ quality: quality}) ]
  })
  // 删除png、jpg图片
  fs.readdirSync(dir).filter((file) => {
    // 踩坑：=== ('.png'|| '.jpg')  运算优先级
    const excludeType = path.extname(file).toLowerCase() === ('.png'|| '.jpg');
    if(excludeType){
      const deleteFile = path.join(dir, file);
      try {
        fs.unlink(deleteFile);
      } catch {
        console.log('未成功删除png、jpg图片');
      }
    }
    return file;
  })
  // 串行、并行转换复习一下
  for (let i = 0, len = res.length; i < len; i++) {
    if (res[i].isDirectory()) {
      // 如果有文件夹，继续往深处读取转换
      await recurConvert(path.join(dir, res[i].name)); 
    }
  }
}
```

- 使用脚本：

  ```js
  const imageMin = require('imagemin');
  const imageMinWebp = require('imagemin-webp');
  const path = require('path');
  const fs = require('fs');
  
  // 从输入参数中读取：指定转换的目录、转换质量
  // node ./convertScript.js  /public  75
  const quality = process.argv[3] || 75;
  const startDir = path.join(__dirname, './', process.argv[2]);
  recurConvert(startDir); // 从当前所在根目录开始读取
  ```

> #### 写脚本：
>
> - 第一次写脚本，是个蛮有意思的过程，简单学习了文件读写操作等
> - 一点启示：
>   - 期望尝试做点小工具之类的，用于博客工具、懒人工具；
>   - 之前博客魔改，在魔改插件的时候学习下插件的封装，非webpack；

### 二、转换webp的插件

> 由于项目的需要，此处指的是webpack插件；
>
> 基于之前的文章中，我们简单介绍过封装一个插件的过程，今天不再介绍封装插件的步骤，而是想帮助我们更好地封装插件：
>
> - 脚本是如何转换为插件；
> - 梳理一下webpack运行机制，帮助我们了解webpack运行的过程
> - 封装插件时，如何选择合适的时机，这是我比较好奇的一点

> ### 转换插件：
>
> - 只需要将脚本要执行的事情，放在合适的时机钩子里去执行即可；
>
> ```js
> //  导入依赖包和模块...
> class convertWebpWebpackPlugin {
>   constructor(options) {
>     this.options = options;
>   }
>   apply(compiler) {
>     compiler.hooks.compile.tap('convertWebpWebpackPlugin', (compilation) => {
>       //...省略recurConvert函数
>       const { quality, convertPath } = this.options;
>       const startDir = path.join(__dirname, '../', convertPath);
>       const isDir = fs.statSync(startDir).isDirectory();
>       isDir && recurConvert(startDir);
>     });
>   }
> }
> module.exports = convertWebpWebpackPlugin;
> ```
>
> ```js
> new convertWebpWebpackPlugin({
>   quality: 100,
>   convertPath: 'public',
> })
> ```

### 三、优化版本

> 由于项目是在next框架下开发的，尽管这些可以实现webpack中的配置，但在Next中仍然存在问题：
>
> 1. 项目中存在很多png图片，如果直接执行插件，所有png被换位webp，此时项目跑不起来，因为原本代码是找png代码；此时还需要替换；
> 2. 脚本中，出于项目打包体积的考虑，将convert后的webp图片对应的png图片删除了，但如果convert过程中发生了错误，就会导致项目运行时找不到图片的错误；

> #### 1、替换png的loader





> #### 2、优化图片转换过程





### 四、线上资源部署case

> #### loader与plugin的区别是什么？
>
> 在项目开发中，是如何决策需要一个loader解决问题还是plugin？





> #### 替换原生img的解决方
>
> 

