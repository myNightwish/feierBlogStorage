---
title: JS的数据类型
date: 2021-12-10 22:54:19
tags: 'JS'
categories: 'JS'
description: 'JS的数据类型2大类及其特点'
cover: https://images.unsplash.com/photo-1638984849684-e646e7d9659c?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=870&q=80
---


### 数据类型 ###

八种数据类型，分别是基本引用类型与基本引用类型

#### 1.1、原始类型 ####

* `Null`：只包含一个值：`null`

* `Undefined`：只包含一个值：`undefined`

* `Boolean`：包含两个值：`true`和`false`

* `Number`：整数或浮点数，还有一些特殊值（`-Infinity`、`+Infinity`、`NaN`）

  ```
  最大能表示的值：Number.MAX_VALUE=	1.7976931348623157e+308
  Infinity 正无穷 （大于Number.MAX_VALUE的数字）
  -Infinity 负无穷 
  NaN 非法数字（Not A Number）
  0b 开头表示二进制，但是不是所有的浏览器都支持  
  0 开头表示八进制  
  0x 开头表示十六进制 
  ```

* `String`：一串表示文本值的字符序列

* `Symbol`：创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。

* `BigInt`：是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。

#### 1.2、undefined和null的区别 ####

* undefined:  表示"缺少值"，就是此处应该有一个值，但是还没有定义，undefined转为数值时为NaN。典型用法：

  * 变量被声明了，但没有赋值时，就等于undefined
  * 调用函数时，应该提供的参数没有提供，该参数等于undefined
  * 对象没有赋值的属性，该属性的值为undefined
  * 函数没有返回值时，默认返回undefined

* null:  "没有对象"，即该处不应该有值。`null`转换为数值时值为`0`，典型用法：

  * 作为函数的参数，表示该函数的参数不是对象
* 作为对象原型链的终点
  * 不会占用内存,在清理内存占用可以使用`null`赋值

#### typeof null ####

typeof null 的结果是Object。

* 在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 **类型标签(1-3 bits)** 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：

  ```
  000: object   - 当前存储的数据指向一个对象。
    1: int      - 当前存储的数据是一个 31 位的有符号整数。
  010: double   - 当前存储的数据指向一个双精度的浮点数。
  100: string   - 当前存储的数据指向一个字符串。
  110: boolean  - 当前存储的数据是布尔值。
  ```

如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。

有两种特殊数据类型：

* undefined的值是 (-2)30(一个超出整数范围的数字)；
* null 的值是机器码 NULL 指针(null 指针的值全是 0)

那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。

#### 1.3、原始值特点 ####

* 按值访问，变量以变量的标识符和变量的值的形式保存在栈内存中，**栈内存的特点**：
  * 存储的值大小固定
  * 空间较小
  * 可以直接操作其保存的变量，运行效率高
  * 由系统自动分配存储空间
* 值本身是不可被改变的，被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间
  * 比如操作字符串，是在原字符串的基础上产生了一个新字符串，而非直接去改变`str`
* 如果值相等，即返回`true`
* 函数传参：参数**仅仅是被传入变量复制给了的一个局部变量**，改变这个局部变量不会对外部变量产生影响
* 原始类型不能扩展属性和方法，每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而能够调用一些方法和属性。**装箱/拆箱操作**

#### 2.1、引用类型 ####

* 基本引用类型：并不是由`Object`构造的，但是它们原型链的终点都是`Object`

  * `Date` 日期
  * `RegExp` 正则

* 包装类型：基本类型的包装类型:`Boolean`、`Number`、`String`

* 单例内置对象：`Global`、`Math`

* 基本类型和包装类型的主要区别：**对象的生存期**

  * 包装类型使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中
  * 而基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。

  ```js
  var name = 'ConardLi'
  name.color = 'red';
  console.log(name.color); // undefined
  ```

* 集合引用类型：

  * `Object`
  * `Array` 数组
  * `Function` 函数
  * `Map`、`WeakMap`、`Set`、`WeakSet`

#### 2.2、引用类型特点 ####

* 按址访问，该类型的值是同时保存在堆和栈内存中的，这两个栈区共同完成

  * 存储的值大小不定，可动态调整
  * 空间较大，运行效率低
  * 无法直接操作其内部存储，使用引用地址读取
  * 通过代码进行分配空间

* 具有可变性，赋值的时候两个变量保存了同一对象地址，执行同一对象，二者互相影响

* 值的比较：值相等，类型相同，堆中的地址也要相同

* 函数传参：**`ECMAScript`中所有的函数的参数都是按值传递的。**

  参数是引用类型时，同样将参数复制了一个副本到局部变量，只不过**复制的这个副本是指向堆内存中的地址**而已。

  在函数内对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但**这并不代表引用传递**

  ```js
  let obj = {name:'ConardLi'};
  function changeValue(obj){
    obj.name = 'code秘密花园';
  }
  changeValue(obj);
  console.log(obj.name); // code秘密花园
  
  let obj = {};
  function changeValue(obj){
    obj.name = 'ConardLi';
    obj = {name:'code秘密花园'};
  }
  changeValue(obj);
  console.log(obj.name); // ConardLi
  ```