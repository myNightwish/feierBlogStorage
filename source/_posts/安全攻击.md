---
title: XSS和CSRF攻击
date: 2021-12-22 15:33:35
categories: 浏览器
description: 'XSS和CSRF攻击的方式'
cover: https://images.unsplash.com/photo-1640101999152-64d72b089774?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=387&q=80
copyright_author: 飞儿 # 作者覆写
copyright_url: https://www.nesxc.com/post/hexocc.html 
license: CC BY-NC-SA 4.0
license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/
---
##  XSS和CSRF攻击

###  1、XSS攻击

#### 1、概念： ####

- 跨站脚本攻击，攻击者在**网站注入恶意脚本**，当用户浏览网页时，嵌入网页的Script代码会执行，通过对用户浏览器进行控制或者拿到用户隐私数据
- 重点不在于跨站点，XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。
- 攻击者可以通过这种攻击方式可以进行以下操作：
  * 获取页面的数据，如DOM、cookie、localStorage；
  * DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
  * 破坏页面结构；
  * 流量劫持（将链接指向某网站）；

#### 2、类型 ####

##### 1、反射型/非持久型 #####

- 攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 需要服务端交互
- **反射型 XSS 的攻击步骤：**
  1. 攻击者构造出特殊的 URL，其中包含恶意代码。
  2. ⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
  3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
  4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。
- 场景：通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

##### 2、存储型/持久型 #####

* 把恶意脚本**存储到服务器的数据库**当中，浏览器请求数据时，脚本就被传回并执行，达到攻击效果

* **存储型 XSS 的攻击步骤：**

  1. 攻击者将恶意代码提交到⽬标⽹站的数据库中。
  2. ⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
  3. ⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。
  4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。

* 举例：

  当有人在留言内容中插入恶意脚本时，留言肯定会保存到服务器中。

  由于服务器要像每一个访客展示之前的留言内容，所以后面的访客自然会接收到之前留言中的恶意脚本而不幸躺枪

* 场景：带有用户保存数据的网站功能，比如论坛发帖、商品评价、用户私信等等

* 反射型 XSS 跟存储型 XSS 的区别是：

  存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥

##### 3、DOM型 #####

* 不需要服务端交互，**纯粹发生在客户端**
* 通过恶意脚本修改DOM结构，通过修改页面的 DOM 节点形成的 XSS。
* **DOM 型 XSS 的攻击步骤：**
  1. 攻击者构造出特殊的 URL，其中包含恶意代码。
  2. ⽤户打开带有恶意代码的 URL。
  3. ⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。
  4. 恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。
* 举例：看小说的时候下面有小广告，直接改变当前页面的Dom结构
* DOM 型 XSS 跟前两种 XSS 的区别：
  * DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。

#### 3、防范措施： ####

##### 方式1：从浏览器的执行来进行预防，**使用纯前端的方式：** #####

1. 使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）
2. 对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。
   * 拒绝innerHTML, 使用.innerText、.setAttribute、.style，
   * Vue：你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。请只对可信内容使用 HTML 插值，**绝不要**对用户提供的内容使用插值

##### 方式2：使用CSP白名单 #####

* CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。
* 对于用户的任何输入要进行**转码**和**过滤**。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。
  1. CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。
  2. 通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 

##### 方式3：cookie安全策略： #####

* 很多xss攻击都是为获取cookie中内容，这样浏览器禁止JS访问带有HTTPOnly属性的cookie，也可以使用验证码，避免脚本伪装成用户执行一些操作。

* **使用场景：**

  我们访问网站的时候账户信息可能存储在cookie中，方便用户验证信息，转账等页面操作。这种操作可能引发XSS攻击（**反射型**），通过执行当前页面的JS代码，获取到cookie里信息，发给攻击者的网站

* **做法：**在服务端设置首部字段set-cookie为HTTPOnly，这样可以防止用户通过JS获取cookie。对cookie的读写/发送一般有如下字段设置：

  * HTTP-Only：只允许HTTPS/http请求读取cookie，JS代码是无法读取cookie的，发送请求时自动发送cookie
  * secure-Only：只允许HTTPS请求读取，发送请求时自动发送cookie
  * host-Only：只允许主机域名与domain设置完成一致的网站才才能访问cookie

###  2、CSRF

#### 1、概念 ####

跨站请求伪造：

* 攻击者诱导用户进入一个第三方网站，然后该网站向**被攻击网站**发送跨站请求。
* 如果用户在**被攻击网站中保存了登录状态**，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。
* CSRF 攻击的**本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。**

举例：

* 比如登录一个银行的网页，在没有退出当前网页时（保存了登陆态），一般是黑客诱使用户点击链接，打开**第三方网站**黑客网站会发起请求，
* 然后利用用户的cookie（包含用户信息）欺骗服务器，服务器以为请求时正常用户发的就正常处理
* 攻击者盗用了用户的身份，以用户的名义发送了恶意请求
  <img src="https://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg" alt="img" style="zoom: 50%;" />

#### 2、攻击类型： ####

- get型：恶意网站会自动发送http请求，向目标网站发起攻击。比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。
- post型：会利用表单提交，向目标网站发送post请求，达到攻击效果。比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。
- 链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击

#### 3、防范措施 ####

##### 1、进行同源检测 #####

* 服务器根据 http 请求头中 origin 或者 referer 信息来**判断请求是否为允许访问的站点**，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。
  * **origin**：包含请求的域名（不包含path及query）
  * **refer**：包含具体的URL地址
* 这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）

##### 2、token验证 #####

CSRF成功的原因就是攻击的网络请求带有cookie而cookie中有正常用户的身份信息，欺骗了服务器。故在HTTP请求中加入一个随机产生的token，服务器拦截验证这个token是否合法，不合法就拒绝这个网络请求。

- 服务器需要生成一个通过加密算法加密的 Token；

- 将该 Token 保存在 Session 或者 Redis；

- 将该 Token 传给客户端，客户端在请求时要将其 Token 一并带上，如 `GET` 请求 `/api/message?token=xxx` 或 `POST` 请求在form表单追加或 `Ajax` 请求在页面添加，通过 JS 去获取该 meta 值；

- 请求到服务器后，服务器就可以通过解密对比来判断该 Token 的有效性了。

##### 3、Set-Cookie：SameSite                     √ #####

**限制 cookie 不能作为被第三方使用**，即在响应头 `Set-Cookie` 设置 SameSite 属性，表示该 Cookie 访问同源网站而非来源第三方网站。从而可以避免被攻击者利用。

* Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用

### 3、网络劫持有哪几种，如何防范？ ###

⽹络劫持分为两种:

（1）**DNS劫持**: (输⼊京东被强制跳转到淘宝这就属于dns劫持)

* DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器
* 302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容

（2）**HTTP劫持**: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)

DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。