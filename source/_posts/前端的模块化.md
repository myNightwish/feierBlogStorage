---
title: 前端的模块化
date: 2021-12-11 21:56:23
tags:
- 模块化
- CommonJS
- ESModule
categories: 前端工程化
hide: true
description: '前端模块化发展'
cover: https://images.unsplash.com/photo-1474511320723-9a56873867b5?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1172&q=80
copyright_author: 飞儿 # 作者覆写
copyright_url: https://www.nesxc.com/post/hexocc.html 
license: CC BY-NC-SA 4.0
license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/
---
## 模块化总结 ##

### 一、模块化背景 ###

* #### 早期的JS发展： ####

  * 要实现的功能少：JS仅仅作为一种脚本语言，做一些简单的表单验证或动画实现等，代码量少，只需要将JS代码写到script标签中即可；并没有必要放到多个文件中来编写；

* #### 问题出现： ####

  要实现的业务越来越复杂，传统开发模式不能再满足，于是出现了模块化的思想；

  * 前端技术发展飞速，ajax的出现，前后端开发分离，意味着后端返回数据后，用JS前端页面的渲染；
  * SPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要JS来实现；
  * Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤；

* #### 什么叫模块 ####

  * 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起
  * 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信

* #### 模块化的价值： ####

  * 避免命名冲突(减少命名空间污染)
  * 更好的分离, 按需加载
  * 更高复用性：公共模块可以促进代码复用，业务模块可以提升项目的可维护性；
  * 高可维护性：为了满足高内聚低耦合，需要将不具备复用价值的代码抽离成相互独立的模块，有很多关于函数不要超过多少行的经验，所以要做有意义的代码拆分

### 二、模块化演变 ###

#### 1. 阶段1：全局function模式 : 将不同的功能封装成不同的全局函数 ####

* 编码: 将不同的功能封装成不同的全局函数
* 问题: 
  1. 污染全局作用域，容易引起命名冲突或数据不安全，变量可以在外部访问和修改；
  2. 无法管理模块间的依赖关系；模块成员之间看不出直接关系

```js
function m1(){
  //...
}
function m2(){
  //...
}
```

#### 2. 阶段2：namespace模式 : 简单对象封装 ####

* 作用: 减少了全局变量，解决命名冲突
* 问题: 只解决了命名冲突问题，数据不安全(外部可以直接修改模块内部的数据)

```js
let myModule = {
  data: 'www.baidu.com',
  foo() {
    console.log(`foo() ${this.data}`)
  },
  bar() {
    console.log(`bar() ${this.data}`)
  }
}
myModule.data = 'other data' //能直接修改模块内部的数据
myModule.foo() // foo() other data
这样的写法会暴露所有模块成员，内部状态可以被外部改写
```

#### 3. 阶段3：IIFE模式：匿名函数自调用(闭包) ####

* 作用: 数据是私有的, 外部只能通过暴露的方法操作
* 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口
* 问题: 如果当前这个模块依赖另一个模块怎么办?

```js
// index.html文件
<script type="text/javascript" src="module.js"></script>
<script type="text/javascript">
    myModule.foo()
    myModule.bar()
    console.log(myModule.data) //undefined 不能访问模块内部数据
    myModule.data = 'xxxx' //不是修改的模块内部的data
    myModule.foo() //没有改变
</script>
```

```js
// module.js文件
(function(window) {
  let data = 'www.baidu.com'
  //操作数据的函数
  function foo() {
    //用于暴露有函数
    console.log(`foo() ${data}`)
  }
  function bar() {
    //用于暴露有函数
    console.log(`bar() ${data}`)
    otherFun() //内部调用
  }
  function otherFun() {
    //内部私有的函数
    console.log('otherFun()')
  }
  //暴露行为
  window.myModule = { foo, bar } //ES6写法
})(window)
```

![img](https://segmentfault.com/img/remote/1460000017466124?w=419&h=105)

#### 4. 阶段4：IIFE模式增强 : 引入依赖 ####

现代模块实现的基石

```js
// module.js文件
(function(window, $) {
  let data = 'www.baidu.com'
  //操作数据的函数
  function foo() {
    //用于暴露有函数
    console.log(`foo() ${data}`)
    $('body').css('background', 'red')
  }
  function bar() {
    //用于暴露有函数
    console.log(`bar() ${data}`)
    otherFun() //内部调用
  }
  function otherFun() {
    //内部私有的函数
    console.log('otherFun()')
  }
  //暴露行为
  window.myModule = { foo, bar }
})(window, jQuery)
 // index.html文件
  <!-- 引入的js必须有一定顺序 -->
  <script type="text/javascript" src="jquery-1.10.1.js"></script>
  <script type="text/javascript" src="module.js"></script>
  <script type="text/javascript">
    myModule.foo()
  </script>
```

上例子通过jquery方法将页面的背景颜色改成红色，所以必须先引入jQuery库，就把这个库当作参数传入。**这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显**。

* #### 阶段5：各种规范出现 ####

  **引入多个`script`后出现问题**

  * 请求过多

  首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多

  * 依赖模糊

  不知道他们的具体依赖关系，很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。

  * 难以维护

  以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。
  模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。

  而这些问题可以通过模块化规范来解决，目前主流的 `JavaScript` 模块化规范有 **CommonJS**，AMD，CMD，**ES6 Module** 四种规范

### 三、CommonJS ###

#### 1. 概念： ####

1. **node提出**的标准，**在node服务端运行**，但**不适合浏览器**中使用；
2. 在服务器端，模块的加载是**运行时同步加载**的；在**浏览器端，模块需要提前编译打包处理**
3. 核心变量：exports、module.exports、require；
4. Node中每个js文件都是个单独的模块，单独的作用域，在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见；

#### 2. 特点： ####

* 所有代码都运行在模块作用域，不会污染全局作用域。
* 模块**可多次加载**，但是**只会在第一次加载时运行一次，然后运行结果就被缓存了**，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
* 模块加载的顺序，按照其在代码中出现的顺序

#### 3. 基本语法 ####

* 暴露模块：`module.exports = value`或`exports.xxx = value`

* 引入模块：`require(xxx)`

  如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径；

  **require命令，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错**

* **CommonJS暴露的模块到底是什么?** 

  CJS规定，每个模块内部，module变量代表当前模块。

  这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。

  **加载某个模块，其实是加载该模块的module.exports属性**。

```js
// example.js
var x = 5;
var addX = function (value) {
  return value + x;
};
module.exports.x = x;
module.exports.addX = addX;
```

上面代码通过module.exports输出变量x和函数addX。

```js
//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径
var example = require('./example.js');
console.log(example.x); // 5
console.log(example.addX(1)); // 6
```

#### 4. 模块的加载机制 ####

* **输入的是被输出的值的拷贝**

  一旦输出一个值，模块内部的变化就影响不到这个值。这点与ES6模块化有重大差异

```js
// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
};
```

上面代码输出内部变量counter和改写这个变量的内部方法incCounter。

```js
// main.js
var counter = require('./lib').counter;
var incCounter = require('./lib').incCounter;

console.log(counter);  // 3
incCounter();
console.log(counter); // 3
```

上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。**这是因为counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值**。

### 四、ES6 Module ###

设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。

#### 1. 基本语法 ####

* export命令用于规定模块的对外接口

  ```js
  /** 定义模块 math.js **/
  var basicNum = 0;
  var add = function (a, b) {
      return a + b;
  };
  export { basicNum, add };
  ```

* import命令用于输入其他模块提供的功能

  ```js
  /** 引用模块 **/
  import { basicNum, add } from './math';
  function test(ele) {
      ele.textContent = add(99 + basicNum);
  }
  ```

* 使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载，为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到**export default**命令，为模块指定默认输出，其他模块加载该模块时，import命令可以为该匿名函数指定任意名字

  ```js
  // export-default.js
  export default function () {
    console.log('foo');
  }
  // import-default.js
  import customName from './export-default';
  customName(); // 'foo'
  ```

#### 2. 动态加载 ####

* 通过import加载一个模块，是不可以在其放到逻辑代码中的，比如：

  ```js
  if(true){
  	import sub from './xxx'
  }
  ```

  报错：unexpected identifier（语法错误）

  原因：解析阶段执行的放在运行阶段执行，导致报错

  * JS代码时交给JS引擎执行经过：Parse --- AST --- 字节码 --- 二进制代码 --- 执行
  * parse过程只是对语法进行了分析，并没有执行，此时就必须知道它的依赖关系，就已经确定了依赖关系。
  * 这个时候js代码没有任何的运行，所以无法在进行类似于if判断中根据代码的执行情况；

* **那如何动态地加载模块呢？**  --import() 函数

  ```js
  let flag = true;
  if(flag){
  	import('./xxx.js').then(res => {
  		res.fun1();
  	}).catch(err => {console.log(err)})
  } else {
  	import('./xxx.js').then(res => {
  		res.fun2();
  	}).catch(err => {console.log(err)})
  }
  ```

  * import函数返回的是一个promise；

  * export default {}的形式导出，此时promise 的res.default是一个对象，结果存放在这里

    ```
    取得时候：res.default.fun1
    ```

  * 脚手架中的import 基于webpack ，所以webpack会对import函数进行解析，将（）里面的内容单独打包到JS文件，到时候多个JS文件在首屏渲染的时候，就不需一次性加载一个非常大的文件，等到用这个文件时再加载即可

  * 在webpack环境下，一般用require，它支持ES CJS。若在es module环境下用import函数

### 五、对比差异 ###

#### 1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 ####

* **CommonJS**
  * 通过module.exports导出的是一个对象，可以将这个对象的引用在其他模块中赋值给其他变量；
  * 但是最终他们指向的都是同一个对象，那么一个变量修改了对象的属性，所有的地方都会被修改；
* **ES Module**
  * export在导出一个变量时，js引擎会解析这个语法，并且创建**模块环境记录**；
  * **模块环境记录**会和变量进行实时绑定；
  * 在导入的地方，可以实时获取到绑定的最新值；所以，如果在导出的模块中修改了变化，那么导入的地方可实时获取最新的变量；
  * JS引擎在实时绑定时，一旦发现值发生改变，并不是直接赋值，而是将之前的值删除，用新的值绑定，再将新的值放入记录中，用的时候也是拿这个值。
  * 注意：在导入的地方不可以修改变量，因为它只是被绑定到了这个变量上（其实是一个常量）
    <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210126224604142.png" alt="image-20210126224604142" style="zoom:50%;" />

#### 2. CommonJS 模块是运行时同步加载，ES6 模块是编译时输出接口，异步加载 ####

* **CommonJS**
  * 运行时：CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。js引擎在**执行js代码的过程**中加载模块；
  * 同步的就意味着一个文件没有加载结束之前，后面的代码都不会执行；

* **ES Module**
  * 编译时（解析）时加载，意味着import不能和运行时相关内容一起使用，所以也称ES Module是静态解析的，而不是动态或者运行时解析的；
    * 比如from后面的路径需要动态获取；
    * 比如不能将import放到if等语句的代码块中；
  * 异步：JS引擎遇到import时会去获取这个js文件，但是这个获取过程是异步的，并不会阻塞主线程继续执行；

    * 也就是说**设置了 type=module 的代码，相当于在script标签上也加上了 async 属性**；
    * 如果我们后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行；结果：② --- ①
      <img src="C:\Users\小虎牙\AppData\Roaming\Typora\typora-user-images\image-20210126224230472.png" alt="image-20210126224230472" style="zoom:67%;" />