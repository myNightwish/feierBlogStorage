---
title: JS的执行编译过程
tags:
  - 编译执行
categories: JS
description: 关于JS引擎的编译、执行阶段
cover: >-
  https://images.unsplash.com/photo-1554727267-c24af00c3253?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=509&q=80
copyright_author: 飞儿
copyright_url: 'https://www.nesxc.com/post/hexocc.html'
license: CC BY-NC-SA 4.0
license_url: 'https://creativecommons.org/licenses/by-nc-sa/4.0/'
abbrlink: 3783644122
date: 2021-12-11 22:07:47
---
## JS执行过程、垃圾、内存泄漏 ##

<img src="https://img-blog.csdnimg.cn/20201129121945306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdmZWlqaXU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

### 1、JS执行过程----编译                ###

* JS是解释型语音，所以它无需提前编译，而是由解释器实时运行
* JS代码执行时，两个过程：编译阶段和执行阶段
* 在编译阶段 `JS` 引擎主要做了三件事：词法分析、语法分析和代码生成

#### 1、词法分析 ####

* `JS` 引擎会将代码将代码分解成词元（token），每个词法单元`token`不可再分割
* 例如，`var a = 2` ，这段程序会被分解成：“var、a、=、2、；” 五个 `token` 

#### 2、语法分析 ####

* 对词元（token）转换成树状结构的 “抽象语法树（AST）”

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/7/170b245d2c0ba592~tplv-t2oaga2asx-watermark.awebp" alt="2语法分析.png" style="zoom:25%;" />

#### 3、生成可执行代码 ####

**将`AST`转换为可执行代码的过程**

* 使用翻译器（translator），将代码转为字节码（bytecode）

* 使用字节码解释器（bytecode interpreter），将字节码转为机器码，最终计算机执行的就是机器码

* 即时编译：

  为了提高运行速度，现代浏览器一般采用即时编译，即**字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存**

### 2、执行上下文分类                ###

* 执行程序需要有执行环境， 同样解析 `JavaScript` 也需要执行环境，称它为“执行上下文”
* JS是解释型语言，所以它无需提前编译，而是由解释器实时运行

#### 1、全局执行上下文 ####

* 是默认的、最基础的执行上下文，一个程序中只能存在一个全局执行上下文
* 做的事情：
  1. 在执行全局代码前，创建一个全局对象，在浏览器中就是 `window` 对象
  2. 对全局数据进行预处理：
     * var定义的全局变量==>undefined, 添加为window的属性
     * function声明的全局函数==>赋值(fun), 添加为window的方法
     * 将 `this` 指针指向这个全局对象(window)
  3. 开始执行全局代码

#### 2、函数执行上下文 ####

* 每次**调用函数时**，都会为该函数**创建**对应的函数执行上下文对象(虚拟的, 存在于栈中)
* 一个程序中可以存在任意数量的函数执行上下文，每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤

* 对局部数据进行预处理：
  1. 形参变量==>赋值(实参)==>添加为执行上下文的属性
  2. `arguments`==>赋值(实参列表), 添加为执行上下文的属性 -->[不懂的同学看这里](https://developer.mozilla.org/zh-CN/docs/orphaned/Web/JavaScript/Reference/Functions/arguments)
  3. var定义的局部变量==>undefined, 添加为执行上下文的属性
  4. function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
  5. this==>赋值(调用函数的对象)

* 每个函数都拥有自己的执行上下文，但是只有**在函数被调用的时候**才会被创建

 * 开始执行函数体代码

### 3、管理执行上下文--执行栈 ###


* 执行栈：栈结构，用来存储代码运行时创建的所有执行上下文
* JS引擎如何创建执行上下文：
  1. 当 `JavaScript` 引擎首次读取脚本时，会创建一个全局执行上下文(window)并将其推入当前执行栈
  2. 每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈的顶端
  3. 引擎会运行执行上下文在执行栈顶端的函数，当此函数运行完成后，其对应的执行上下文将会从执行栈中弹出
  4. 上下文控制权将移到当前执行栈的下一个执行上下文
  5. 当所有的代码执行完后, 栈中只剩下window：`上下文栈数==函数调用数+1`

【注意】：作用域与执行上下文不是同一概念：

* 执行上下文在运行时，随时可变，甚至没有过上下文（从不调用），调用完毕销毁。而作用域不改变

### 4、创建执行上下文 ###

JS引擎创建执行上下文分为两个阶段：**创建阶段 和 执行阶段**

#### 1、创建阶段：在JS代码执行之前，该阶段会发生三件事： ####

##### 1、This 绑定： #####

1. 全局执行上下文中，`this` 的值指向全局对象

2. 函数执行上下文中，`this` 的值取决于该函数是如何被调用的

   如果它被一个引用对象调用，那么 `this` 会被设置成那个对象

   否则 `this` 的值被设置为全局对象或者 `undefined`（在严格模式下）

##### 2、创建词法环境组件： #####

词法环境：是一种持有**标识符（变量/函数的名字）—变量映射（对实际对象[包含函数类型对象]或原始数据的引用）**的结构，内部组成两部分：

1. **环境记录器**：存储变量和函数声明的实际位置
2. **外部环境的引用**：意味着它可以访问其父级词法环境（作用域）

词法环境的2种类型：

1. **全局环境**：

   （在全局执行上下文中）是没有外部环境引用的词法环境，外部环境引用是 **null**

   它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 `this`的值指向全局对象

2. **函数环境**

   函数内部用户定义的变量存储在**环境记录器**中

   并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数

**环境记录器**也有两种类型：

* **声明式环境记录器**存储变量、函数和参数。注意他还包含了一个传递给函数的 `arguments` 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。               函数环境
* **对象环境记录器**用来定义出现在**全局上下文**中的变量和函数的关系。     全局环境

##### 3、**创建**变量环境组件 #####

* 变量环境：

  也是一个词法环境，有着上面定义的词法环境的所有属性

  在 ES6 中，**词法环境**组件和**变量环境**的一个不同就是前者被用来存储函数声明和变量（`let` 和 `const`）绑定，而后者只用来存储 `var` 变量绑定

* 为什么可以在声明之前访问 `var` 定义的变量（虽然是 `undefined`）?

  * 因为在创建阶段时，**引擎检查代码找出变量和函数声明，**变量最初设置为 `undefined`（`var` 情况下）
  * 而`let` 和 `const` 定义的变量并没有关联任何值
  * 所以在声明之前访问 `let` 和 `const` 的变量会得到一个引用错误。这也是所说的变量提升

#### 2、执行阶段：完成对所有这些变量的分配，最后执行代码 ####

* 变量对象和作用域链是ES3规范中的内容，ES5之后就不再用了
* **注意** — 在执行阶段，如果 JS 引擎不能在源码中声明的实际位置（说明已经被声明过了）找到 `let` 变量的值，它会被赋值为 `undefined`

### 3、执行上下文 ----- 执行阶段      ES3规范 ###

解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：

<img src="https://img-blog.csdnimg.cn/20201129121945306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdmZWlqaXU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

* 执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）

* **VO（变量对象）和AO（活动对象）**

  * VO中会存放一些变量信息（如声明的变量，函数，`arguments`参数等等）
  * 在函数上下文中：`VO === AO`
  * 在全局上下文中：`VO === this === global`

  变量对象：

  1. 每个执行上下文都会分配一个变量对象
  2. 变量对象的属性由变量和函数声明构成，在函数上下文情况下，参数列表也会被加入到变量对象中作为属性
  3. 变量对象与当前作用域息息相关：不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量

* **作用域链**：

  * 在函数上下文中，查找一个变量foo，如果函数的VO中找到了，就直接使用
  * 否则去它的父级作用域链中（__parent__）找
  * 如果父级中没找到，继续往上找，直到全局上下文中也没找到就报错

* **this机制等**：

  * 当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻
  * this的值只取决中进入上下文时的情况

* 每一个执行上下文，都有三个重要属性：

  * 变量对象(`Variable object，VO`)
  * 作用域链(`Scope chain`)
  * `this`

### 4、作用域与执行上下文的区别与联系 ###

>1. 区别1:
>
>* 全局作用域之外，每个函数都会创建自己的作用域，`作用域在函数定义时就已经确定了。而不是在函数调用时`
>* 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建
>* 函数执行上下文是在调用函数时, 函数体代码执行之前创建
>
>2. 区别2:
>
>* 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
>* 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放
>
>3. 联系:
>
>* 执行上下文(对象)是从属于所在的作用域
>* 全局上下文环境==>全局作用域
>* 函数上下文环境==>对应的函数使用域
>
>![image-20210727141319410](C:/Users/小虎牙/Desktop/JavaScript笔记/A_JavaScript进阶学习笔记中的图片/image-20210727141319410.png)